<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" type="text/css" href="assets/style.css" />
    <title>totk-lotuskit</title>
<script type="module">
    import { createRef, h, render, Component } from "/assets/js-vendor/preact@10.23.1.mjs";
    import htm from "/assets/js-vendor/htm@3.1.1.mjs";
    const html = htm.bind(h);
    import { signal } from "/assets/js-vendor/preact-signals@1.3.0.mjs";
    import fuzzysort from "/assets/js-vendor/fuzzysort@3.1.0.mjs";
    import { getText } from "/assets/translate.mjs";

    // prepare actor search
    import { Actor_MasterList_prepare_fuzzysort } from "/assets/data/Actor_MasterList.mjs";
    const Actor_MasterList_fuzzysort = Actor_MasterList_prepare_fuzzysort(fuzzysort);

    // prepare eventflow search
    import { Event_NameList_prepare_fuzzysort } from "/assets/data/Event_NameList.mjs";
    const Event_NameList_fuzzysort = Event_NameList_prepare_fuzzysort(fuzzysort);


    class WSTransport {
        static websock = undefined;
        static ns_subscriptions = {}; // {ns_json_pointer: [cbfunc, ...]}
        static signals = {
            config: {
                frontend: {
                    ws_is_connected: signal(false),
                },
            },
        };

        static send(data, skipEncode) {
            if (!skipEncode) {
                data = JSON.stringify(data);
            }
            WSTransport.websock.send(data);
        }

        static _ws_on_open(e) {
            console.log(getText("ws open success"));
            WSTransport.signals.config.frontend.ws_is_connected.value = true;
        }
        static _ws_on_close(e) {
            console.log(getText("ws closed"));
            WSTransport.signals.config.frontend.ws_is_connected.value = false;
        }
        static _ws_on_message(e) {
            WSTransport.consume_ws_msg(JSON.parse(e.data));
        }

        static connect(ws_location) {
            if (WSTransport.signals.config.frontend.ws_is_connected.value) {
                console.log(getText("ws closing to reopen"));
                WSTransport.signals.config.frontend.ws_is_connected.value = false;
            }
            if (WSTransport.websock) {
                WSTransport.websock.close(); // XXX mod doesnt really know how to close (or reopen TODO), so this will eventually timeout instead
                WSTransport.websock.removeEventListener("open", WSTransport._ws_on_open);
                WSTransport.websock.removeEventListener("close", WSTransport._ws_on_close);
                WSTransport.websock.removeEventListener("message", WSTransport._ws_on_message);
                WSTransport.websock = undefined;
            }

            ws_location = ws_location || "ws://127.0.0.1:7072";
            console.log(getText("ws open try"), ws_location);
            WSTransport.websock = new WebSocket(ws_location);
            WSTransport.websock.addEventListener("open", WSTransport._ws_on_open);
            WSTransport.websock.addEventListener("close", WSTransport._ws_on_close);
            WSTransport.websock.addEventListener("message", WSTransport._ws_on_message);
        }

        static consume_ws_msg(payload) {
            const ns = payload.sys.ns;
            if (ns in WSTransport.ns_subscriptions) {
                WSTransport.ns_subscriptions[ns].forEach(cb => cb(payload));

            } else if ("msg" in payload) {
                console.log(payload["msg"]);

            } else if ("err" in payload) {
                console.error(payload["err"]);
            }
        }

        static subscribe_ns(ns, cbfunc) {
            if (ns in WSTransport.ns_subscriptions) {
                if (WSTransport.ns_subscriptions[ns].indexOf(cbfunc) != -1) { return; } // dupe
                WSTransport.ns_subscriptions[ns].push(cbfunc);
            } else {
                WSTransport.ns_subscriptions[ns] = [cbfunc];
            }
        }

        static unsubscribe_ns(ns, cbfunc) {
            if (!(ns in WSTransport.ns_subscriptions)) { return; }
            const i = WSTransport.ns_subscriptions[ns].indexOf(cbfunc);
            if (i == -1) { return; }
            WSTransport.ns_subscriptions[ns].splice(i, 1);
        }

        static subscribe_ns_async(cb_user_begin, cb_user_each, ns) {
            ns ||= "/tmp/subscribe_ns_async"; // default

            return new Promise((res, rej) => {
                function cb(payload) {
                    if (cb_user_each(payload)) {
                        // user cb is done with subscription
                        WSTransport.unsubscribe_ns(ns, cb);
                        res(); // return to await
                    }
                }
                WSTransport.subscribe_ns(ns, cb);

                // eg ask mod for something now that subscription is ready
                if (cb_user_begin) { cb_user_begin(ns); }
            });
        }
    };


    class AngelScript {
        // These module names aren't special, but every unique module on the stack needs to have a different name:
        // modules are built once per name per script execution, so while you can push the same name twice (recursion) it won't build/update with the script source you've sent.
        // So if they're going to coexist on the stack, separate code needs to be in separate modules:
        // the module name is like a function identifier which expires once the whole script completes.
        // XXX maybe just send unique/hashed module names so nobody needs to think about this?
        static TAS_MODULE_DEFAULT = "web_anon.as"; // only things like buttons should be anon, oneshot "leaf" executions which can be pushed anytime
        static TAS_MODULE_USER_REPL = "web_scratch.as"; // console/notepad/etc interactive usage (so we can still push anon buttons while this runs)
        static TAS_MODULE_INTERRUPT = "web_interrupt.as"; // cant be anon because it needs to be able to interrupt anon

        static wrap_implicit_main(script_text) {
            // no begin newline preserves line numbers
            // end newline closes any trailing line comment
            // AS has a line offset setting but its not worth the plumbing rn
            return `void main() { ${script_text}\n}`;
        }

        static exec(snippet, moduleName) {
            WSTransport.send({
                execScriptString: AngelScript.wrap_implicit_main(snippet),
                execScriptModule: moduleName || AngelScript.TAS_MODULE_DEFAULT,
                blockOnDebugPause: false, // noblock on DebugPause (for toolbar buttons etc) XXX rename AngelScript.exec
            });
        }
    }

    class RemoteFileUtil {
        static async reqDumpTextFile(filename, ns) {
            ns ||= "/tmp/fs/dump/" + filename.split("/").at(-1).split(".").at(0); // default

            let output = "";
            await WSTransport.subscribe_ns_async(
                () => AngelScript.exec(`Logger::dumpTextFileIntoNS("${filename}", "${ns}");`), // begin
                payload => {
                    if (payload.msg) { output += payload.msg; } // accumulate file contents
                    if (payload.endDump) { return true; } // resolve
                },
                ns // accumulation scope
            );

            return output;
        }

        static async reqDirectoryIndex(path, ns) {
            ns ||= "/tmp/fs/index/" + path.split("/").at(-1); // default

            let output = [];
            await WSTransport.subscribe_ns_async(
                () => AngelScript.exec(`Logger::dumpDirectoryIndexIntoNS("${path}", "${ns}");`), // begin
                payload => {
                    if (payload.endDump) { return true; } // resolve
                    output.push(payload); // accumulate dentries
                },
                ns // accumulation scope
            );

            return output;
        }

        static navigatorDownload(content, filename, mimeType) { // XXX doesnt really belong here
            mimeType ||= "text/plain";
            const blob = new Blob([content], {type: mimeType});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.setAttribute('href', url);
            a.setAttribute('download', filename);
            a.click();
            URL.revokeObjectURL(url);
        }
    }


    // general vector stuff

    class VecUtil {
        static UI_HEIGHT_OFFSET = 105.5;
        static engine_to_ui(engine_vec3) { return [engine_vec3[0],                       -1 * engine_vec3[2], engine_vec3[1] - VecUtil.UI_HEIGHT_OFFSET]; }
        static ui_to_engine(    ui_vec3) { return [    ui_vec3[0],     ui_vec3[2] + VecUtil.UI_HEIGHT_OFFSET,                           -1 * ui_vec3[1]]; }
    }

    const VecComponentPatterns = {
        XYZ: "XYZ",
        XZY: "XZY",
        ZX:  "ZX",
        ZXY: "ZXY",
    };


    // ui util

    function makeLegibleFloat(value) { return parseFloat(value.toFixed(6)); }

    function CompassSpinny({value}) {
        const [rz, rx] = value;
        const rad = Math.atan2(rz, rx);

        let ns = rz > 0 ? 'S' : 'N';
        let ew = rx > 0 ? 'E' : 'W';
        if (Math.abs(rz) == 1.0) { ew = "\xa0"; }
        if (Math.abs(rx) == 1.0) { ns = "\xa0"; }

        return html`<span style="transform: rotate(${rad}rad);" class="compass_spinny vec_components_${VecComponentPatterns.ZX}"><span>${ns}</span><span>${ew}</span>‚Üí</span>`
    }

    function CompassSpinnyPhysics({value}) { // Quatf
        const rad = (-2 * Math.atan2(value[1], value[3])) + Math.PI/2;
        // FIXME calc NSEW from rad
        return html`<span style="transform: rotate(${rad}rad);" class="compass_spinny"><span>\xa0</span><span>\xa0</span>‚Üí</span>`
    }

    function ReadoutVec3({label, value, vecComponentPattern, title}) {
        const v = value;
        const c = vecComponentPattern || "";
        return html`<span label=${label} title=${title} class="readout readout_vec3 vec_components_${c}"><span>${makeLegibleFloat(v[0])}</span> <span>${makeLegibleFloat(v[1])}</span> <span>${makeLegibleFloat(v[2])}</span></span>`;
    }
    function ReadoutVec2({label, value, vecComponentPattern, title}) {
        const v = value;
        const c = vecComponentPattern || "";
        return html`<span label=${label}  title=${title} class="readout readout_vec2 vec_components_${c}"><span>${makeLegibleFloat(v[0])}</span> <span>${makeLegibleFloat(v[1])}</span></span>`;
    }
    function ReadoutQuat({label, value, vecComponentPattern, title}) {
        const v = value;
        const c = vecComponentPattern || "";
        return html`<span label=${label} title=${title} class="readout readout_quat vec_components_${c}"><span>${makeLegibleFloat(v[0])}</span> <span>${makeLegibleFloat(v[1])}</span> <span>${makeLegibleFloat(v[2])}</span> <span>${makeLegibleFloat(v[3])}</span></span>`;
    }

    class SimpleWindow extends Component {
        constructor() {
            super();
            this.dialogRef = createRef();
            this.state = {
                windowDragOrigin: null,
                mouseDragOrigin: null,
            };
        }

        do_dialog_keydown = (e) => {
            if (e.key == "Escape" || e.keyCode == 27) {
                e.preventDefault();
                this.props.onClose(); // request close
            }
        }

        do_drag_end = (e) => { this.setState({windowDragOrigin: null, mouseDragOrigin: null}); }
        do_drag_begin = (e) => {
            const dialog = this.dialogRef.current;
            //const rect = dialog.getBoundingClientRect();
            //console.log([rect.left, rect.top], [...window.lastMouseClientPagePos]);
            //console.log(dialog.style.left || 0, dialog.style.top || 0);
            this.setState({
                //windowDragOrigin: [rect.left, rect.top],
                windowDragOrigin: [parseInt(dialog.style.left) || 0, parseInt(dialog.style.top) || 0],
                mouseDragOrigin: [...window.lastMouseClientPagePos], // copy
            });

            let loop; // rAF until mouse up
            loop = () => {
                if (!this.state.windowDragOrigin) { return; } // break
                // HACK the dialog is somehow getting positioned relative to quickcorner for x axis, or something? but only firefox. no idea why i needed 2 either
                // FIXME it goes goofy too far right, or scrolling during drag
                //const qcOffset = document.querySelector(".toolset_quickcorner").getBoundingClientRect().left;
                //console.log('loopx',  this.state.windowDragOrigin[0],  window.lastMouseClientPagePos[0],  this.state.mouseDragOrigin[0], qcOffset);
                dialog.style.left = (this.state.windowDragOrigin[0] + 2*(window.lastMouseClientPagePos[0] - this.state.mouseDragOrigin[0])) + "px";
                dialog.style.top  = (this.state.windowDragOrigin[1] +    window.lastMouseClientPagePos[1] - this.state.mouseDragOrigin[1])  + "px";
                window.requestAnimationFrame(loop);
            };
            window.requestAnimationFrame(loop);
        }

        render(props, state) {
            return html`
                <dialog ref=${this.dialogRef} onKeyDown=${this.do_dialog_keydown} open>
                    <button title=${getText("drag to move window")} onMouseDown=${this.do_drag_begin} onMouseUp=${this.do_drag_end} class="pushbutton move"></button>
                    <button title=${getText("esc when focused to close")} onClick=${props.onClose} class="pushbutton hint_destructive_hover esc"></button>
                    ${props.children}
                </dialog>
            `;
        }
    };


    // main ui
    class WorldHacks extends Component {
        doPresetPerfectDay() {
            AngelScript.exec([
                "world::doHackFogDisable(false);",
                "world::setFogDensity(0, 0, 0);",
                "world::setTimeHM(12,00);",
                "world::setWeather(0);",
                "world::setWind(0, 0, 0);",
            ].join("\n"));
        }

        doPresetPerfectNight() {
            AngelScript.exec([
                "world::doHackFogDisable(true);",
                "world::setFogDensity(0, 0, 0);",
                "world::setTimeHM(00,00);",
                "world::setWeather(0);",
                "world::setWind(0, 0, 0);",
            ].join("\n"));
        }

        render() {
            return html`
                <span style="margin-left: 32px;">${getText("World")}:</span>
                <button title=${getText("Perfect day (noon, clear fog, clear weather, clear wind)")} onClick=${() => this.doPresetPerfectDay() } class="pushbutton hint_sparkles_corner">‚òÄÔ∏è</button>
                <button title=${getText("Perfect night (midnight, clear+hack fog, clear weather, clear wind)")} onClick=${() => this.doPresetPerfectNight() } class="pushbutton hint_sparkles_corner">üåò</button>
            `;
        }
    };

    class FrameAdvance extends Component {
        constructor() {
            super();
            this.step_n = createRef();
        }

        doTogglePausePlay() {
            AngelScript.exec([
                `auto req = "DebugPause";`,
                `if (pause::isPauseRequest(req)) {`,
                    `tas::endFrameAdvance();`,
                `} else {`,
                    `tas::beginFrameAdvance();`,
                `}`,
            ].join("\n"));
        }
        doStepAS() {
            const step_n = this.step_n.current.value || 1;
            AngelScript.exec(`tas::stepFrameAdvance(${step_n});`);
        }
        doStepSleep() {
            const step_n = this.step_n.current.value || 1;
            AngelScript.exec([
                `tas::doBlockOnDebugPause(true);`, // further tas frames in this script only (ie the sleep(n) below) will be blocked by DebugPause...
                                                   // (interrupts usually run throughout DebugPause but we opt out here to keep it consistent between interactive + AS usage)
                `tas::stepFrameAdvance(${step_n});`, // ...but we immediately unpause DebugPause anyways
                `sys::suspendCtx();`, // yield to ^ scheduling, should resume next calc:
                `tas::sleep(${step_n});`, // and run through the frames, using human control
            ].join("\n"));
        }

        render(props, state) {
            return html`
                <span class="frameadvance" style="margin-left: 16px;">
                    ${getText("Frame")}:
                    <button title=${getText("DebugPause increment/decrement")} onClick=${() => this.doTogglePausePlay() } class="pushbutton" style="font-size:1.5rem;">\u23ef</button>
                    <button title=${getText("step ahead (in an already-running script)")} onClick=${() => this.doStepAS() } class="pushbutton hint_blueprint_strong hover_hasargs" style="font-size: 2.5rem; vertical-align: bottom; line-height: 0;"><span style="transform: rotateY(180deg); display: inline-block;">\u293d</span></button>
                    <button title=${getText("step ahead (controller passthrough)")} onClick=${() => this.doStepSleep() } class="pushbutton hint_controller_corner hover_hasargs hover_isarg" style="font-size: 2.5rem; vertical-align: bottom; line-height: 0;"><span style="transform: rotateY(180deg); display: inline-block;">\u293d</span></button>
                    <input class="hover_isarg" style="width: 48px" type="number" placeholder="1" size="2" min="1" step="any" ref=${this.step_n} />
                </span>
            `;
        }

    };

    class CameraHacks extends Component {
        constructor() {
            super();

            // dump
            this.pos = createRef();
            this.at = createRef();
            this.up = createRef();

            // ActorWatcher relative
            this.slot_i = createRef();
            this.dist = createRef();
            this.elev = createRef();
            this.follow = createRef();
            this.relative = createRef();
            this.setState({relative: false}); // XXX should just bind state to input

            // PlayerUtil LStick hacks
            this.lstick_slot_i = createRef();
            this.lstick_pos = createRef();
            this.lstick_rad = createRef();

            WSTransport.subscribe_ns("/camera/log", this.recvCameraLog.bind(this))
        }

        recvCameraLog(payload) {
            let v = payload["pos"].map(x => makeLegibleFloat(x));
            this.pos.current.value = `${v[0]}, ${v[1]}, ${v[2]}`;

            v = payload["at"].map(x => makeLegibleFloat(x));
            this.at.current.value = `${v[0]}, ${v[1]}, ${v[2]}`;

            v = payload["up"].map(x => makeLegibleFloat(x));
            this.up.current.value = `${v[0]}, ${v[1]}, ${v[2]}`;
        }

        reqCameraLog() { AngelScript.exec("camera::log();"); }
        reqToggleFreeze() { AngelScript.exec("camera::toggleFreeze();"); }
        reqFreezeAtDumpRefs() {
            let pos = this.pos.current.value;
            pos = pos.replaceAll(",", "").split(" ").filter(x => x !== "").map(x => parseFloat(x));

            let at = this.at.current.value;
            at = at.replaceAll(",", "").split(" ").filter(x => x !== "").map(x => parseFloat(x));

            let up = this.up.current.value;
            up = up.replaceAll(",", "").split(" ").filter(x => x !== "").map(x => parseFloat(x));

            AngelScript.exec(`camera::freeze(${up[0]}, ${up[1]}, ${up[2]}, ${pos[0]}, ${pos[1]}, ${pos[2]}, ${at[0]}, ${at[1]}, ${at[2]});`);
        }

        reqFreezeAtActorWatcher(staticvec) {
            let slot_i = this.slot_i.current.value || 0;
            let dist = this.dist.current.value || 20;
            let elev = this.elev.current.value || 5;
            let follow = this.follow.current.checked;
            let relative = this.relative.current.checked;
            //console.log(`camera::freezeAtActorWatcher(${slot_i}, ${dist}, Vector3f::${staticvec}, ${elev}, ${follow}, ${relative});`);
            AngelScript.exec(`camera::freezeAtActorWatcher(${slot_i}, ${dist}, Vector3f::${staticvec}, ${elev}, ${follow}, ${relative});`);
        }

        reqLStickAbsVanilla() { AngelScript.exec("PlayerUtil::doLStickAbsoluteVanilla();"); }
        reqLStickAbsCam() { AngelScript.exec("PlayerUtil::doLStickAbsoluteCameraFreeze();"); }
        reqLStickAbsPlayer() { AngelScript.exec("PlayerUtil::doLStickAbsolutePlayer();"); }
        reqLStickAbsPos() {
            let pos = this.lstick_pos.current.value || "Player.pos";
            // promote number lists to vec, else passthrough expr
            if(/^[0-9a-fA-Fx ,.]+$/.test(pos)) {
                pos = `Vector3f(${pos})`;
            }
            AngelScript.exec(`PlayerUtil::doLStickAbsoluteTargetPos(${pos});`);
        }
        reqLStickAbsRad() {
            let rad = this.lstick_rad.current.value || "PI";
            AngelScript.exec(`PlayerUtil::doLStickAbsoluteRadOffset(${rad});`);
        }
        reqLStickAbsAW() {
            let slot_i = this.lstick_slot_i.current.value || 0;
            AngelScript.exec(`PlayerUtil::doLStickAbsoluteTargetActorWatcher(${slot_i});`);
        }

        render(props, state) {
            const rel = state.relative === true;
            const titleAW = `camera::freezeAtActorWatcher(${getText("slot_i")}, ${getText("dist")}, Vector3f, ${getText("elev")}, ${getText("follow")}, ${getText("relative")})`;

            return html`
                <div class="camerahacks" style="margin-top: 8px;">
                    ${getText("Camera")}
                    <button title="camera::toggleFreeze()" onClick=${() => this.reqToggleFreeze() } class="pushbutton hint_recommended_hover" style="font-size:1.5rem;">\u23ef</button>
                    <label title=${getText("update with ActorWatcher position")} for="camerahacks_follow">${getText("follow")}:</label>
                    <input type="checkbox" id="camerahacks_follow" ref=${this.follow} checked />
                    <label title=${getText("rotate relative to actor")} for="camerahacks_relative">${getText("rel")}:</label>
                    <input type="checkbox" id="camerahacks_relative" ref=${this.relative} onChange=${() => this.setState({relative: this.relative.current.checked}) } />
                    <${WorldHacks} />

                    <div style="float:right;">
                        <button title="camera::log()" onClick=${() => this.reqCameraLog() } class="pushbutton">${getText("dump")}</button>
                        <button title="camera::freeze(${getText("up")}, ${getText("pos")}, ${getText("at")})" onClick=${() => this.reqFreezeAtDumpRefs() } class="pushbutton">${getText("assign")}</button>
                        <br/>
                        ${getText("pos")}: <input placeholder="x, y, z" ref=${this.pos} size=20 /><br />
                        ${getText("at")}: <input placeholder="x, y, z" ref=${this.at} size=20 /><br />
                        ${getText("up")}: <input placeholder="0, 0.707161, -0.707161" ref=${this.up} size=20 /><br />
                    </div>
                    <br/>

                    <button title=${titleAW} onClick=${() => this.reqFreezeAtActorWatcher("NW") } class="pushbutton">${rel ? "‚Üò"  : getText("NW")}</button>
                    <button title=${titleAW} onClick=${() => this.reqFreezeAtActorWatcher("N" ) } class="pushbutton">${rel ? "12" : getText("N" )}</button>
                    <button title=${titleAW} onClick=${() => this.reqFreezeAtActorWatcher("NE") } class="pushbutton">${rel ? "‚Üô"  : getText("NE")}</button>
                    <button inert class="pushbutton pushbutton_inert_spacer">__</button>
                    <span><label title=${getText("target camera to selected actor slot")} for="camerahacks_slot_i">ActorWatcher[</label><input id="camerahacks_slot_i" style="width: 35px" type="number" placeholder="0" size="2" min="0" step="any" ref=${this.slot_i} />]</span>

                    <br/>
                    <button title=${titleAW} onClick=${() => this.reqFreezeAtActorWatcher("W" ) } class="pushbutton">${rel ? "9" : getText("W" )}</button>
                    <button inert class="pushbutton pushbutton_inert_spacer">üåê</button>
                    <button title=${titleAW} onClick=${() => this.reqFreezeAtActorWatcher("E" ) } class="pushbutton">${rel ? "3" : getText("E" )}</button>
                    <button inert class="pushbutton pushbutton_inert_spacer">__</button>
                    <span><label title=${getText("xz distance from target (offset = dist * direction)")} for="camerahacks_dist">dist: </label><input id="camerahacks_dist" style="width: 60px;" type="number" placeholder="20" size="4" min="-10000" max="10000" step="any" ref=${this.dist} />m</span>

                    <br/>
                    <button title=${titleAW} onClick=${() => this.reqFreezeAtActorWatcher("SW") } class="pushbutton">${rel ? "‚Üó" : getText("SW")}</button>
                    <button title=${titleAW} onClick=${() => this.reqFreezeAtActorWatcher("S" ) } class="pushbutton">${rel ? "6" : getText("S" )}</button>
                    <button title=${titleAW} onClick=${() => this.reqFreezeAtActorWatcher("SE") } class="pushbutton">${rel ? "‚Üñ" : getText("SE")}</button>
                    <button inert class="pushbutton pushbutton_inert_spacer">__</button>
                    <span><label title=${getText("camera.pos_y = target.pos_y + elev")} for="camerahacks_elev">elev: </label><input id="camerahacks_elev" style="width: 60px;" type="number" placeholder="5" size="4" min="-10000" max="10000" step="any" ref=${this.elev} />m</span>

                    <!--<button title="camera::toggleFreeze()" onClick=${() => this.reqToggleFreeze() } class="pushbutton" style="transform: rotate(-45deg);">‚üµ45¬∞</button>-->

                    <br /><span style="margin-top: 12px; display: inline-block;">${getText("LStick")}:</span>
                    <button class="hint_recommended_hover" title="PlayerUtil::doLStickAbsoluteVanilla(); // ${getText("reset/default")}" onClick=${() => this.reqLStickAbsVanilla() }>\u23f5</button>
                    <button title="PlayerUtil::doLStickAbsoluteCameraFreeze(); // ${getText("hold controls based on current view")}" onClick=${() => this.reqLStickAbsCam() }>üé•</button>
                    <button title="PlayerUtil::doLStickAbsolutePlayer(); // ${getText("up is Link's forward")}" onClick=${() => this.reqLStickAbsPlayer() } style="color: #f9fc31; transform: scaleY(1.5); line-height: 14px;">‚Æù</button>
                    <button style="margin-left: 8px;" class="hover_hasargs" title="PlayerUtil::doLStickAbsoluteRadOffset(rad); // ${getText("up is: 0 south, PI north, -PI_2 west, +PI_2 east")}" onClick=${() => this.reqLStickAbsRad() }>üåê</button><input class="hover_isarg" placeholder="PI" ref=${this.lstick_rad} size=4 />
                    <button style="margin-left: 8px;" class="hover_hasargs" title="PlayerUtil::doLStickAbsoluteTargetActorWatcher(${getText("slot_i")});" onClick=${() => this.reqLStickAbsAW() }>AW[</button><input class="hover_isarg" style="width: 35px" type="number" placeholder="0" size="2" min="0" step="any" ref=${this.lstick_slot_i} /><span class="hover_isarg">]</span>
                    <button style="margin-left: 8px;" class="hover_hasargs" title="PlayerUtil::doLStickAbsoluteTargetPos(Vector3f);" onClick=${() => this.reqLStickAbsPos() }>pos:</button><input class="hover_isarg" placeholder="x, y, z" ref=${this.lstick_pos} size=20 />

                </div>
            `;
        }
    };

    class FpsHacks extends Component {
        constructor() {
            super();
            this.setState({});
            WSTransport.subscribe_ns("/fps/log", payload => { this.setState(payload) });
        }

        do_send_toggle(opt) { const v = this.state[opt] ? "false" : "true"; AngelScript.exec(`fps::${opt}(${v});`); }

        render(props, state) {
            return html`
                <span class=${getText("fpshacks")} style="margin-left: 6px;">
                    FPS:
                    <label title="fps::doTextWriter(${getText('checked')})" class="faketoggle doTextWriter" for="fps_doTextWriter">
                        <input type="checkbox" id="fps_doTextWriter" checked=${state.doTextWriter} onChange=${ e => this.do_send_toggle("doTextWriter") } />
                        <span class="fakebutton pushbutton">${getText("txt")}</span>
                    </label>
                    <button title="fps::fixedFPS(30)" onClick=${() => AngelScript.exec("fps::fixedFPS(30);") }>30</button>
                    <button title="fps::fixedFPS(20)" onClick=${() => AngelScript.exec("fps::fixedFPS(20);") }>20</button>
                    <button title="fps::fixedFPS(0)"  onClick=${() => AngelScript.exec("fps::fixedFPS(0);") } class="hint_recommended_hover">${getText("reset")}</button>
                </span>
            `;
        }
    }

    class PauseHacks extends Component {
        constructor() {
            super();
            this.pausenameref = createRef();
            this.setState({pauseName: "LoadingPause", isPauseReq: true});
            WSTransport.subscribe_ns("/pause/log", payload => { this.setState(payload) });
        }

        static PauseReqAll = ["LoadingPause", "DebugPause", "ClickPause", "EventDisableController", "EventDisableController_Camera", "ReverseRecorderPause", "PreGamePause", "GamePause", "PostGamePause", "EventBancChangePause", "GameOverPause", "ResetGimmickFromScript", "UpdateBancResource", "SceneBeginning", "EventPlayMovie", "EventSetupOrRestore", "GamePauseWithoutEvent", "SystemPauseWhileLoading", "UpdateResourcePause", "ResetGimmick", "AutoBuilderPause", "SceneTransition"];

        static PauseTargetAll = ["AI", "AS", "Actor", "Blackboard", "CSharp", "Camera", "Controller", "Custom_ASGlobalFrame", "Custom_ActorCalcDrawExceptPouchActor", "Custom_ActorCalcExceptAutoBuilderActor", "Custom_ActorCalcExceptFarDelete", "Custom_ActorCalcExceptOpeningEventActor", "Custom_ActorCalcExceptPlayerEquipment", "Custom_ActorCalcExceptPlayer", "Custom_ActorCalc", "Custom_ActorDraw", "Custom_ActorRenderingProxy", "Custom_AllowCalcScript", "Custom_AllowStartScript", "Custom_AmiiboMgr", "Custom_AttentionSystem", "Custom_AutoPlacementMgr", "Custom_AutoSaveCount", "Custom_AutoSave", "Custom_BancLoadMgrCheckGameData", "Custom_BancRealtimeEdit", "Custom_ChallengeFollowerMgr", "Custom_Chemical", "Custom_CompanionMgrSummon", "Custom_Controller_Camera", "Custom_Controller_Player", "Custom_Controller_UI", "Custom_CraftSignboardMgr", "Custom_DragonMgr", "Custom_DynamicResolution", "Custom_EffectAutoBuild", "Custom_EffectReverseRecorder", "Custom_EffectSystem", "Custom_EnergyGaugeMgr", "Custom_Footprint", "Custom_ForbidLoadingPause", "Custom_GSysAndController", "Custom_GSysPauseMenu", "Custom_GSys", "Custom_GameBalance", "Custom_GameEffect", "Custom_LaunchParameterMgr", "Custom_LightBallBudMgr", "Custom_Logic", "Custom_NpcPhysicsProcOnReset", "Custom_PerceptionCalc", "Custom_PhysicsUpdateWorld", "Custom_PlayReportCount", "Custom_Player", "Custom_ReverseRecorder", "Custom_SceneDraw", "Custom_Sequence", "Custom_SkipDamageCalc", "Custom_SoundBgm", "Custom_SoundEnv", "Custom_SoundPauseAll", "Custom_SoundWorldExceptEnv", "Custom_SpecialPowerFilter", "Custom_StopCotrollerRumble", "Custom_StopSaveLiveToGameData", "Custom_TimerMgr", "Custom_UpdateBancResource", "Custom_WaitLoadForUI", "Custom_WorldMgrImm", "Custom_WorldMgr", "Dengu", "Ecpp", "Effect", "Error", "Event", "GameData", "Graphics", "LOD", "ProgramHotReload", "Reaction", "Resource", "Rumble", "Scene", "Tool", "UI", "Visualize", "XLink"];

        static PauseReqOptions = PauseHacks.PauseReqAll.map(v => html`<option>${v}</option>`);
        static PauseTargetOptions = PauseHacks.PauseTargetAll.map(v => html`<option>${v}</option>`);

        on_select_pause = (e) => {
            const name = e.currentTarget.value;
            const isreq = PauseHacks.PauseReqAll.indexOf(name) !== -1;
            this.setState({pauseName: name, isPauseReq: isreq});
        }

        do_requestPause() { AngelScript.exec(`pause::requestPause("${this.pausenameref.current.value}");`); }
        do_releasePause() { AngelScript.exec(`pause::releasePause("${this.pausenameref.current.value}");`); }
        do_unfreeze() { AngelScript.exec("pause::doFreezeMask(false);"); }
        do_freeze_nopause() { AngelScript.exec("pause::freezeMask(0, 0, 0, 0);"); }
        do_freeze_selection() {
            const name = this.pausenameref.current.value;
            const isreq = PauseHacks.PauseReqAll.indexOf(name) !== -1;
            if (isreq) {
                AngelScript.exec(`pause::freezeRequest("${this.pausenameref.current.value}");`);
            } else {
                AngelScript.exec(`pause::freezeTarget("${this.pausenameref.current.value}");`);
            }
        }
        do_send_toggle(opt) { const v = this.state[opt] ? "false" : "true"; AngelScript.exec(`pause::${opt}(${v});`); }

        render(props, state) {
            const reqStyle = state.isPauseReq ? "" : "background: #666; color: #aaa;";
            const reqFreezeTitle = state.isPauseReq ? `pause::freezeRequest(${getText("string")})` : `pause::freezeTarget(${getText("string")})`;
            const reqTitle = state.isPauseReq ? `pause::requestPause(${getText("string")})` : getText(`[invalid for PauseTargets]`);
            const relTitle = state.isPauseReq ? `pause::releasePause(${getText("string")})` : getText(`[invalid for PauseTargets]`);

            return html`
                <div class="pausehacks">
                    PauseMgr:
                    <label title="pause::doTextWriter(${getText('checked')})" class="faketoggle doTextWriter" for="pause_doTextWriter">
                        <input type="checkbox" id="pause_doTextWriter" checked=${state.doTextWriter} onChange=${ e => this.do_send_toggle("doTextWriter") } />
                        <span class="fakebutton pushbutton">${getText("txt")}</span>
                    </label>
                    <label title="pause::doTextWriterExtended(${getText('checked')})" class="faketoggle doTextWriterExtended" for="pause_doTextWriterExtended">
                        <input type="checkbox" id="pause_doTextWriterExtended" checked=${state.doTextWriterExtended} onChange=${ e => this.do_send_toggle("doTextWriterExtended") } />
                        <span class="fakebutton pushbutton">${getText("ext")}</span>
                    </label>
                    <${FpsHacks} />
                    <br />

                    <select ref=${this.pausenameref} onChange=${this.on_select_pause} style="width: 200px;">
                        <optgroup label="PauseRequest">
                        ${PauseHacks.PauseReqOptions}
                        </optgroup>
                        <optgroup label="PauseTarget">
                        ${PauseHacks.PauseTargetOptions}
                        </optgroup>
                    </select>
                    <button title=${reqFreezeTitle} onClick=${() => this.do_freeze_selection() } class="pushbutton">\u23f8</button>
                    <button title="pause::doFreezeMask(false); // ${getText("end pause freezing")}" onClick=${() => this.do_unfreeze() } class="pushbutton hint_recommended_hover">\u23f5</button>
                    <button title="pause::freezeMask(0, 0, 0, 0); // ${getText("force unpause")}" onClick=${() => this.do_freeze_nopause() } class="pushbutton">0</button>
                    <button style=${reqStyle} title=${relTitle} onClick=${() => this.do_releasePause() } class="pushbutton dec">-</button>
                    <button style=${reqStyle} title=${reqTitle} onClick=${() => this.do_requestPause() } class="pushbutton inc">+</button>
                </div>
            `;
        }
    };

    class StaminaHacks extends Component {
        do_freeze_vanilla() { AngelScript.exec(`PlayerUtil::freezeStaminaExhaustion(false); PlayerUtil::freezeStaminaRecovery(0);`); }
        do_freeze_recover() { AngelScript.exec(`PlayerUtil::freezeStaminaRecovery(30000);`); }
        do_freeze_exhaust() { AngelScript.exec(`PlayerUtil::freezeStaminaExhaustion(true);`); }
        do_freeze_norecover() { AngelScript.exec(`PlayerUtil::freezeStaminaRecovery(-1);`); }

        render(props, state) {
            return html`
                <div class="staminahacks" style="margin-left: 40px;">
                    ${getText("Stam")}:
                    <button title="/* ${getText("reset/default")} */ PlayerUtil::freezeStaminaExhaustion(false); PlayerUtil::freezeStaminaRecovery(0);" onClick=${() => this.do_freeze_vanilla() } class="pushbutton hint_recommended_hover"><img src="assets/img/stamina_normal.png" /></button>
                    <button title="PlayerUtil::freezeStaminaRecovery(30000); // ${getText("always fast recover")}" onClick=${() => this.do_freeze_recover() } class="pushbutton"><img src="assets/img/stamina_extra.png" /></button>
                    <button title="PlayerUtil::freezeStaminaExhaustion(true); // ${getText("always exhausted")}" onClick=${() => this.do_freeze_exhaust() } class="pushbutton"><img src="assets/img/stamina_red.png" /></button>
                    <button title="PlayerUtil::freezeStaminaRecovery(-1); // ${getText("never recover")}" onClick=${() => this.do_freeze_norecover() } class="pushbutton hint_snowflake_corner"><img src="assets/img/stamina_low.png" /></button>
                </div>
            `;
        }
    };

    class HexDumpSlot extends Component {
        constructor() {
            super();
            this.slotLabelRef = createRef();
            this.slotTargetPtrRef = createRef();
            this.slotFormatHexRef = createRef();
            this.slotDataTypeRef = createRef();
            this.dumpLen = createRef();
            this.drawLen = createRef();
        }

        do_absolute(i) {
            const drawLen = parseInt(this.drawLen.current.value) || 0x20;
            const dumpLen = drawLen; // XXX prob dont need it
            const label = this.slotLabelRef.current.value.toString() || "HexDump";
            const ptr = this.slotTargetPtrRef.current.value || 0;
            const dataType = this.slotDataTypeRef.current.value || 0; // default u8
            const formatHex = this.slotFormatHexRef.current.checked;
            if (!ptr) { console.log(getText("bad hexdump pointer?"), i); return; }
            AngelScript.exec(`HexDump::assignSlotAbsolute(${i}, ${ptr}, ${dumpLen}, ${drawLen}, "${label}", ${dataType}, ${formatHex});`);
            console.log(getText("hexdump absolute"), i, ptr, {dumpLen, drawLen, label});
        }
        do_pause(i) {
            AngelScript.exec(`HexDump::pauseSlot(${i});`);
            console.log(getText("hexdump pause"), i);
        }
        do_clear(i) {
            AngelScript.exec(`HexDump::clearSlot(${i});`);
            console.log(getText("hexdump clear"), i);
        }
        on_select_datatype = (e) => {
            const datatype = parseInt(e.currentTarget.value);
            // flip formatHex to a reasonable default for the type (float, double ignored)
            // hex or raw default: u8, u16, u32, u64, text
            if ([0, 1, 2, 3, 10].indexOf(datatype) !== -1) { this.slotFormatHexRef.current.checked = true; }
            // dec or formatted default: s8, s16, s32, s64, code (prefer addr formatting instead of raw hex)
            if ([4, 5, 6, 7, 11].indexOf(datatype) !== -1) { this.slotFormatHexRef.current.checked = false; }
        }

        render({slot_i}, state) {
            // TODO symbol picker? ptr_from_sym("farts") in the box works already tho
            // enum HexDumpDataType: U8=0, U16, U32, U64, S8, S16, S32, S64, FLOAT, DOUBLE, TEXT, CODE_AARCH64
            return html`
                <div class="hexdump_slot">
                    ${slot_i}${"\xa0"}
                    <input placeholder=${getText("label")} size="6" ref=${this.slotLabelRef} />
                    <!-- TODO <select>${getText("absolute, main, ...")}</select> -->
                    <input placeholder=${getText("target ptr")} size="30" ref=${this.slotTargetPtrRef} />
                    <!--<input placeholder="0x20" size="6" ref=${this.dumpLen} />-->
                    <input placeholder="0x20" size="6" ref=${this.drawLen} />
                    <label title=${getText("format as hex or decimal")} for="hexdump_fmthex_${slot_i}">0x</label>
                    <input title=${getText("format as hex or decimal")}  id="hexdump_fmthex_${slot_i}" type="checkbox" ref=${this.slotFormatHexRef} checked />
                    <select style="max-width: 64px;" ref=${this.slotDataTypeRef} onChange=${this.on_select_datatype}>
                        <option value="0">\xa0u8</option>
                        <option value="1">u16</option>
                        <option value="2">u32</option>
                        <option value="3">u64</option>
                        <option value="4">\xa0s8</option>
                        <option value="5">s16</option>
                        <option value="6">s32</option>
                        <option value="7">s64</option>
                        <option value="8">${getText("float")}</option>
                        <option value="9">${getText("double")}</option>
                        <option value="10">${getText("text")}</option>
                        <option value="11">${getText("code")}</option>
                    </select>
                    <button onClick=${ () => this.do_absolute(slot_i) } class="pushbutton hint_recommended_hover">${getText("dump")}</button>
                    <button onClick=${ () => this.do_pause(slot_i) } class="pushbutton">${getText("pause")}</button>
                    <button onClick=${ () => this.do_clear(slot_i) } class="pushbutton hint_destructive_hover">${getText("clear")}</button>
                </div>
            `;
        }
    };

    class MemSearch extends Component {
        constructor() {
            super();
            this.needle_ptr_ref = createRef();
        }

        do_search(haystack_name_UNUSED) {
            // TODO more search types
            const needle_ptr = this.needle_ptr_ref.current.value || 0;
            AngelScript.exec(`sys::memSearch(${needle_ptr});`);
        }

        render(props, state) {
            // TODO region/scope picker
            return html`
                <div class="memsearch">
                    ${getText("Memory search")}<span title=${getText("crashes on console")}>‚ö†Ô∏è</span><br/>
                    <input placeholder=${getText("target ptr")} size="20" ref=${this.needle_ptr_ref} />
                    <button title="sys::memSearch(${getText("input")})" onClick=${ () => this.do_search("sead::HeapMgr::sRootHeaps") } class="pushbutton">${getText("heap")}</button>
                </div>
            `;
        }
    };

    class QuickDumps extends Component {
        // TODO display output somewhere?
        constructor() {
            super();
            this.sleep_n = createRef();
        }
        do_heapInfo() { AngelScript.exec("sys::heapInfo();"); }
        do_threadInfo() { AngelScript.exec("sys::threadInfo();"); }
        do_hookLimits() { AngelScript.exec("sys::hookLimits();"); }
        doSleep() {
            // this isnt important enough for main tas/frameadvance/etc ui so it goes here for now
            const frame_n = this.sleep_n.current.value || 1;
            AngelScript.exec(`tas::sleep(${frame_n});`);
        }
        render(props, state) {
            return html`
                <div class="quickdumps">
                    ${getText("Quick dumps")} <br/>
                    <button title="sys::heapInfo()" onClick=${ () => this.do_heapInfo() } class="pushbutton">${getText("heaps")}</button>
                    <button title="sys::threadInfo()" onClick=${ () => this.do_threadInfo() } class="pushbutton">${getText("threads")}</button>
                    <button title="sys::hookLimits()" onClick=${ () => this.do_hookLimits() } class="pushbutton">${getText("hooks")}</button>
                    <button class="pushbutton hover_hasargs" title="tas::sleep(n);" onClick=${() => this.doSleep() }>sleep(</button><input class="hover_isarg" style="width: 48px" type="number" placeholder="1" size="2" min="1" step="any" ref=${this.sleep_n} /><span class="hover_isarg">)</span>
                </div>
            `;
        }
    };

    class ExecScript extends Component {
        constructor() {
            super();
            this.setState({
                // tas dump
                isDumping: false,
                dumpMode: "ws",
                isBrowseSD: false,
            });

            this.script_text_ref = createRef();
            this.use_implicit_main_ref = createRef();

            WSTransport.subscribe_ns("/tas/Record", this.recv_tas_dump_ws.bind(this))
            this.tas_dump_filename_ref = createRef();
            this.tas_dump_ws_output_text_ref = createRef();
            this.tas_dump_use_nxtas_ref = createRef();
        }

        do_exec() {
            const script_text = this.script_text_ref.current.value;
            const main = this.use_implicit_main_ref.current.checked;

            WSTransport.send({
                execScriptString: main ? AngelScript.wrap_implicit_main(script_text) : script_text,
                execScriptModule: AngelScript.TAS_MODULE_USER_REPL,
                blockOnDebugPause: true,
            });
        }

        do_tas_upload_filename() {
            const filename = this.tas_dump_filename_ref.current.value || "dump_latest.as";
            const payload = this.tas_dump_ws_output_text_ref.current.value;
            WSTransport.send({persistFileString: payload, persistFileName: filename}); // WARNING this will immediately clobber any file dont fuck around
        }

        async do_tas_download_filename(doBrowserSave) {
            const filename = this.tas_dump_filename_ref.current.value || "dump_latest.as";
            const payload = await RemoteFileUtil.reqDumpTextFile(filename);
            //console.log('dump', filename, payload);
            this.tas_dump_ws_output_text_ref.current.value = payload;
            if (doBrowserSave) {
                const basename = filename.split("/").at(-1); // eg "dump_latest.as"
                RemoteFileUtil.navigatorDownload(payload, basename);
            }
        }

        do_tas_dump_toggle() {
            if (this.state.isDumping) {
                // just end any ongoing recording
                AngelScript.exec("tas::endDump();");
                return;
            }

            const isNXTas = this.tas_dump_use_nxtas_ref.current.value == "nx";
            if (this.state.dumpMode == "ws") {
                if (isNXTas) {
                    AngelScript.exec("tas::beginLoggerDumpNXTas();");
                } else {
                    AngelScript.exec("tas::beginLoggerDump();");
                }

            } else if (this.state.dumpMode == "sdcard") {
                const filename = this.tas_dump_filename_ref.current.value || "dump_latest.as";
                if (isNXTas) {
                    AngelScript.exec(`tas::beginFileDumpNXTas("${filename}");`);
                } else {
                    AngelScript.exec(`tas::beginFileDump("${filename}");`);
                }
            }
        }

        do_tas_dump_mode_select = (e) => {
            const dumpMode = e.currentTarget.value;
            this.setState({dumpMode: dumpMode});
        }

        begin_browse_sd() { this.setState({isBrowseSD: true}); }
        end_browse_sd() { this.setState({isBrowseSD: false}); }
        pick_browse_sd(path) { this.tas_dump_filename_ref.current.value = path; this.end_browse_sd(); }

        on_drop_terrifying_subsdk9_upload = async (e) => {
            const file = e.currentTarget.files[0];
            console.log(getText("dropped:"), file);
            if (!file) { console.log(getText("no file!")); return; }
            if (file.name != "subsdk9") { console.log(getText("weird filename!")); return; }
            if (file.size < 64*1024) { console.log(getText("file seems quite small!")); return; }
            const reader = new FileReader(); // TODO wrap in promise? dumb api
            reader.addEventListener("load", async () => {
                const prefix = "data:application/octet-stream;base64,"; // need to strip this
                if (reader.result.indexOf(prefix) !== 0) { console.log(getText("weird readAsDataURL!")); return; }
                const b64Payload = reader.result.slice(prefix.length);
                const rawPayload = window.atob(b64Payload);
                if (rawPayload.slice(0, 4) !== "NSO0") { console.log(getText("missing nso header!")); return; }

                const remote_filename = "sdcard:/atmosphere/contents/0100f2c0115b6000/exefs/subsdk9";
                //const remote_filename = "sdcard:/totk_lotuskit/web_test.bin";

                //WSTransport.send({persistFileBinary: b64Payload, persistFileName: remote_filename}); // WARNING this will immediately clobber any file dont fuck around
                const chunkSize = 0x1000;
                for (let i = 0; i < rawPayload.length-1;) {
                    const rawChunk = rawPayload.slice(i, i+chunkSize);
                    const b64Chunk = window.btoa(rawChunk);
                    const op = (i == 0) ? 1 : 2; // open+write then write
                    WSTransport.send({persistFileBinaryChunk: b64Chunk, persistFileName: remote_filename, persistChunkOp: op, persistChunkOffset: i}); // WARNING this will immediately clobber any file dont fuck around
                    i += rawChunk.length;
                }
                WSTransport.send({persistFileBinaryChunk: "", persistFileName: remote_filename, persistChunkOp: 3, persistChunkOffset: 0}); // close
            }, false);
            reader.readAsDataURL(file);
        }

        recv_tas_dump_ws(payload) {
            const el = this.tas_dump_ws_output_text_ref.current;
            if (payload.beginDump) { el.value = ""; this.setState({isDumping: true}); } // wipe on new recording
            else if (payload.endDump) { this.setState({isDumping: false}); }
            else { el.value += payload["msg"]; } // append new input
        }

        renderTasDump(props, state) {
            // TODO extract new component class for dump
            const recordTitle = state.isDumping ? getText("End recording") : getText("Configure + Begin record");
            const recordToggleChar = state.isDumping ? "\u23f9" : "\u23fa";
            const recordActiveClass = state.isDumping ? "recording" : "notrecording";
            const sd_hasargs = state.dumpMode == "sdcard" ? "hover_hasargs" : "";
            const sd_arg = state.dumpMode == "sdcard" ? html`<input class="hover_isarg" placeholder="dump_latest.as" ref=${this.tas_dump_filename_ref} size=36 />` : "";

            const sd_arg_browse = state.dumpMode == "sdcard" ? html`<button title=${getText("Open sdcard browser")} onClick=${ () => this.begin_browse_sd() } class="pushbutton hover_isarg hint_folder_corner" style="color: #aaa; transform: scaleX(0.8); padding: 0 9px; margin-right: -4px;">‚õò</button>` : "";
            const sd_arg_window = state.isBrowseSD ? html`<${RemoteFileBrowser} onClose=${ () => this.end_browse_sd() } onPick=${ path => this.pick_browse_sd(path) } />` : "";

            const sd_download = state.dumpMode == "sdcard" ?  html`<button title=${getText("View remote file (display below)")} onClick=${ () => this.do_tas_download_filename(false) } class="pushbutton hover_isarg hint_eye_corner">üì•Ô∏é</button>` : "";
            const sd_download_save = state.dumpMode == "sdcard" ?  html`<button title=${getText("Download remote file (browser save + display below)")} onClick=${ () => this.do_tas_download_filename(true) } class="pushbutton hover_isarg hint_floppy_corner">üì•Ô∏é</button>` : "";
            const sd_upload = state.dumpMode == "sdcard" ?  html`<button title=${getText("Upload remote file (using contents below)")} onClick=${ () => this.do_tas_upload_filename() } class="pushbutton hover_isarg hint_destructive_hover">üì§Ô∏é</button>` : "";
            const HACK_suppressHeightReflow = html`<button class="pushbutton pushbutton_inert_spacer" inert>üì•Ô∏é</button>`; // always keep a üì•Ô∏é button in layout

            return html`
                    <span title=${getText("Manages tas dumps/transfers")}>${getText("REC")}</span>
                    <button title="${recordTitle}" onClick=${ () => this.do_tas_dump_toggle() } class="pushbutton record_red ${recordActiveClass}">${recordToggleChar}</button>

                    <select style="width: 48px; margin-left: 8px;" ref=${this.tas_dump_use_nxtas_ref} >
                        <option disabled>[${getText("Dump Format")}]</option>
                        <option value="as" title=${getText("Use default AngelScript format")}>as</option>
                        <option value="nx" title=${getText("Use line-based nx-TAS format")}>nx</option>
                    </select>

                    <select class="${sd_hasargs}" onChange=${this.do_tas_dump_mode_select} style="width: 48px;">
                        <option disabled>[${getText("Dump Destination")}]</option>
                        <option value="ws" title=${getText("Dump only to ws (output below)")}>ws</option>
                        <option value="sdcard" title=${getText("Dump only to sdcard (relative to sdcard:/totk_lotuskit/ by default)")}>sd</option>
                    </select>

                    ${sd_arg}
                    ${sd_arg_browse}
                    ${sd_arg_window}
                    ${sd_download}
                    ${sd_download_save}
                    ${sd_upload}
                    ${HACK_suppressHeightReflow}

                    <textarea style="text-wrap: nowrap;" placeholder=${getText("[tas output]")} ref=${this.tas_dump_ws_output_text_ref}></textarea>
            `;
        }

        render(props, state) {
            // TODO local (web client) file save/load, copy, drop to remote, ...
            // TODO ctrl+enter do_exec()
            const nsoDisplay = false ? "inline" : "none"; // XXX feature flags in sessionStorage?

            return html`
                <div class="execscript">
                    <span title=${getText("Manages AngelScript execution/playback for the tas stack")}>AS:</span>
                    <button title=${getText("Run the script below")} onClick=${ () => this.do_exec() } class="pushbutton hint_blueprint_strong">exec</button>
                    <button title="tas::abort()" onClick=${ () => AngelScript.exec("tas::abort();", AngelScript.TAS_MODULE_INTERRUPT) } class="pushbutton hint_destructive_hover">${getText("abort")}</button>
                    <label title=${getText("Automatically wrap input into void main() {...} entry point")} for="execscript_use_implicit_main">main:</label>
                    <input type="checkbox" id="execscript_use_implicit_main" ref=${this.use_implicit_main_ref} checked />

                    <${FrameAdvance} />
                    <span style="float: right; display: ${nsoDisplay};">
                        <label title=${getText("update subsdk9 (drop onto button)")} for="subsdkupload"> nso: </label>
                        <input type="file" title="WSTransport.send({persistFileBinary, persistFileName})" onChange=${this.on_drop_terrifying_subsdk9_upload} class="pushbutton hint_destructive_hover" style="width:32px;" id="subsdkupload" />
                    </span>
                    <br/>
                    <textarea class="as_source" placeholder=${getText("execscript_placeholder")} ref=${this.script_text_ref}></textarea>

                    ${ this.renderTasDump(props, state) }

                </div>
            `;
        }
    };

    class ActorWatcher extends Component {
        constructor() {
            super();
            this.setState({
                actorName: `[${getText("null")}]`,
                actorPtr: 0,
                pos: [0, 0, 0],
                vel: [0, 0, 0],
                rot: [0,0,0, 0,0,0, 0,0,0], // TODO is it even worth rendering this? so noisy
            });
            this.bumper_increment_ref = createRef();
            this.savestate_textbox_pos_ref = createRef();
            this.savestate_textbox_rot_ref = createRef();
            this.selector_textbox_ref = createRef();
        }

        componentDidMount() {
            WSTransport.subscribe_ns(`/ActorWatcher/${this.props.slot_i}`, payload => this.setState(payload));
        }

        assignSlotAwaitSpawn(slot_i) {
            let name = this.selector_textbox_ref.current.value || "";
            name = name.trim();
            AngelScript.exec(`ActorWatcher::assignSlotAwaitSpawn(${slot_i}, "${name}");`);
        }

        assignSlotAwaitRecall(slot_i) {
            AngelScript.exec(`ActorWatcher::assignSlotAwaitRecall(${slot_i});`);
        }

        assignSlotAwaitBancEntityHash(slot_i) {
            let hash = this.selector_textbox_ref.current.value || ""; // u64, needs BigInt for js numeric! leaving as string
            hash = hash.trim();
            if (!hash) { console.error(`assignSlotAwaitBancEntityHash: ${getText("invalid hash")} ${hash}`); }
            AngelScript.exec(`ActorWatcher::assignSlotAwaitBancEntityHash(${slot_i}, ${hash});`);
        }

        clear_slot(slot_i) {
            AngelScript.exec(`ActorWatcher::clearSlot(${slot_i});`);
        }

        do_paste_coords(slot_i, pos, rot) {
            let r = rot;
            if (pos && r) {
                AngelScript.exec(`ActorWatcher::get(${slot_i}).setPosRot(${pos[0]}, ${pos[1]}, ${pos[2]}, ${r[0]}, ${r[1]}, ${r[2]}, ${r[3]}, ${r[4]}, ${r[5]}, ${r[6]}, ${r[7]}, ${r[8]});`);
            } else if (pos) {
                AngelScript.exec(`ActorWatcher::get(${slot_i}).setPos(${pos[0]}, ${pos[1]}, ${pos[2]});`);
            } else if (r) {
                AngelScript.exec(`ActorWatcher::get(${slot_i}).setRot(${r[0]}, ${r[1]}, ${r[2]}, ${r[3]}, ${r[4]}, ${r[5]}, ${r[6]}, ${r[7]}, ${r[8]});`);
            }
        }

        do_relative_move(slot_i, dir) {
            const delta = parseInt(this.bumper_increment_ref.current.value) || 10.0;
            AngelScript.exec(`ActorWatcher::get(${slot_i}).pos += Vector3f::${dir} * ${delta};`);
        }

        do_absolute_move(slot_i) {
            let pos = this.savestate_textbox_pos_ref.current.value;
            pos = pos.replaceAll(",", " ").split(" ").filter(x => x !== "").map(x => parseFloat(x));
            let rot = this.savestate_textbox_rot_ref.current.value;
            rot = rot.replaceAll(",", " ").split(" ").filter(x => x !== "").map(x => parseFloat(x));

            // TODO engine/ui/objmap coord conversions?
            this.do_paste_coords(slot_i, pos, rot);
        }

        do_send_toggle(slot_i, funcname, rawValue, translateFalseValue, translateTrueValue) {
            const v = ( rawValue && translateTrueValue  !== undefined) ? translateTrueValue  :
                      (!rawValue && translateFalseValue !== undefined) ? translateFalseValue : rawValue;
            AngelScript.exec(`ActorWatcher::${funcname}(${slot_i}, ${v});`);
        }

        dump_pos_to_savestate_textbox() {
            let v = this.state.pos.map(x => makeLegibleFloat(x));
            this.savestate_textbox_pos_ref.current.value = `${v[0]}, ${v[1]}, ${v[2]}`;
            let r = this.state.rot.map(x => makeLegibleFloat(x));
            this.savestate_textbox_rot_ref.current.value = `${r[0]}, ${r[1]}, ${r[2]}, ${r[3]}, ${r[4]}, ${r[5]}, ${r[6]}, ${r[7]}, ${r[8]}`;
        }

        render(props, state) {
            const {actorName, actorPtr, pos, vel} = state;
            const i = this.props.slot_i;
            const ptr = "0x" + actorPtr.toString(16).padStart(16, "0");
            const dummy = [0, 0, 0, 0]; // XXX

            return html`
                <section class="toolset_actor_watcher">
                    <div class="actor_selector_current">
                        ${actorName}(${ptr})
                        <div class="actor_toggles">
                            <div>
                                <label title="ActorWatcher::doWSLog(${i}, ${getText('checked')})" class="faketoggle doWSLog" for="aw${i}_doWSLog">
                                    <input type="checkbox" id="aw${i}_doWSLog" checked=${state.doWSLog} onChange=${ e => this.do_send_toggle(i, "doWSLog", e.target.checked) } />
                                    <span class="fakebutton pushbutton">${getText("ws")}</span>
                                </label>
                                <label title="ActorWatcher::doTextWriter(${i}, ${getText('checked')})" class="faketoggle doTextWriter" for="aw${i}_doTextWriter">
                                    <input type="checkbox" id="aw${i}_doTextWriter" checked=${state.doTextWriter} onChange=${ e => this.do_send_toggle(i, "doTextWriter", e.target.checked) } />
                                    <span class="fakebutton pushbutton">${getText("txt")}</span>
                                </label>
                                <label title="ActorWatcher::doDrawPos(${i}, ${getText('checked')})" class="faketoggle doDrawPos" for="aw${i}_doDrawPos">
                                    <input type="checkbox" id="aw${i}_doDrawPos" checked=${state.doDrawPos} onChange=${ e => this.do_send_toggle(i, "doDrawPos", e.target.checked) } />
                                    <span class="fakebutton pushbutton">${getText("pos")}</span>
                                </label>
                                <label title="ActorWatcher::doDrawAABB(${i}, ${getText('checked')})" class="faketoggle doDrawAABB" for="aw${i}_doDrawAABB">
                                    <input type="checkbox" id="aw${i}_doDrawAABB" checked=${state.doDrawAABB} onChange=${ e => this.do_send_toggle(i, "doDrawAABB", e.target.checked) } />
                                    <span class="fakebutton pushbutton">${getText("AABB")}</span>
                                </label>
                                <label title="ActorWatcher::doDrawVel(${i}, ${getText('checked')})" class="faketoggle doDrawVel" for="aw${i}_doDrawVel">
                                    <input type="checkbox" id="aw${i}_doDrawVel" checked=${state.doDrawVel} onChange=${ e => this.do_send_toggle(i, "doDrawVel", e.target.checked) } />
                                    <span class="fakebutton pushbutton">${getText("vel")}</span>
                                </label>
                                <label title="ActorWatcher::doDrawAngVel(${i}, ${getText('checked')})" class="faketoggle doDrawAngVel" for="aw${i}_doDrawAngVel">
                                    <input type="checkbox" id="aw${i}_doDrawAngVel" checked=${state.doDrawAngVel} onChange=${ e => this.do_send_toggle(i, "doDrawAngVel", e.target.checked) } />
                                    <span class="fakebutton pushbutton">${getText("angv")}</span>
                                </label>
                                <label title="ActorWatcher::doDrawModelPos(${i}, ${getText('checked')})" class="faketoggle doDrawModelPos" for="aw${i}_doDrawModelPos">
                                    <input type="checkbox" id="aw${i}_doDrawModelPos" checked=${state.doDrawModelPos} onChange=${ e => this.do_send_toggle(i, "doDrawModelPos", e.target.checked) } />
                                    <span class="fakebutton pushbutton">${getText("pos")}</span>
                                </label>
                            </div>

                            <div class="row2">
                                <label title="ActorWatcher::doWSRigidBody(${i}, flagset_t)" class="faketoggle doWSRigidBody" for="aw${i}_doWSRigidBody">
                                    <input type="checkbox" id="aw${i}_doWSRigidBody" checked=${state.doWSRigidBody}
                                           onChange=${ e => this.do_send_toggle(i, "doWSRigidBody", e.target.checked, 0, 0xffffffffffffffffn) } />
                                    <span class="fakebutton pushbutton">${getText("ws")}</span>
                                </label>
                                <label title="ActorWatcher::doTextWriterRigidBody(${i}, flagset_t)" class="faketoggle doTextWriterRigidBody" for="aw${i}_doTextWriterRigidBody">
                                    <input type="checkbox" id="aw${i}_doTextWriterRigidBody" checked=${state.doTextWriterRigidBody}
                                           onChange=${ e => this.do_send_toggle(i, "doTextWriterRigidBody", e.target.checked, 0, 0xffffffffffffffffn) } />
                                    <span class="fakebutton pushbutton">${getText("txt")}</span>
                                </label>
                                <label title="ActorWatcher::doDrawRigidBodyPos(${i}, flagset_t)" class="faketoggle doDrawRigidBodyPos" for="aw${i}_doDrawRigidBodyPos">
                                    <input type="checkbox" id="aw${i}_doDrawRigidBodyPos" checked=${state.doDrawRigidBodyPos}
                                           onChange=${ e => this.do_send_toggle(i, "doDrawRigidBodyPos", e.target.checked, 0, 0xffffffffffffffffn) } />
                                    <span class="fakebutton pushbutton">${getText("pos")}</span>
                                </label>

                                <label title="ActorWatcher::doDrawRigidBodyPosPast(${i}, flagset_t)" class="faketoggle doDrawRigidBodyPosPast" for="aw${i}_doDrawRigidBodyPosPast">
                                    <input type="checkbox" id="aw${i}_doDrawRigidBodyPosPast" checked=${state.doDrawRigidBodyPosPast}
                                           onChange=${ e => this.do_send_toggle(i, "doDrawRigidBodyPosPast", e.target.checked, 0, 0xffffffffffffffffn) } />
                                    <span class="fakebutton pushbutton">${getText("pos-")}</span>
                                </label>

                                <label title="ActorWatcher::doDrawRigidBodyPosFuture(${i}, flagset_t)" class="faketoggle doDrawRigidBodyPosFuture" for="aw${i}_doDrawRigidBodyPosFuture">
                                    <input type="checkbox" id="aw${i}_doDrawRigidBodyPosFuture" checked=${state.doDrawRigidBodyPosFuture}
                                           onChange=${ e => this.do_send_toggle(i, "doDrawRigidBodyPosFuture", e.target.checked, 0, 0xffffffffffffffffn) } />
                                    <span class="fakebutton pushbutton">${getText("pos+")}</span>
                                </label>

                                <label title="ActorWatcher::doDrawRigidBodyAABB(${i}, flagset_t)" class="faketoggle doDrawRigidBodyAABB" for="aw${i}_doDrawRigidBodyAABB">
                                    <input type="checkbox" id="aw${i}_doDrawRigidBodyAABB" checked=${state.doDrawRigidBodyAABB}
                                           onChange=${ e => this.do_send_toggle(i, "doDrawRigidBodyAABB", e.target.checked, 0, 0xffffffffffffffffn) } />
                                    <span class="fakebutton pushbutton">${getText("AABB")}</span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="actor_selector_options">
                        ${getText("Select")}:
                        <button title="ActorWatcher::clearSlot(${i})" onClick=${ () => this.clear_slot(i) } class="pushbutton hint_destructive_hover">${getText("null")}</button>
                        <button title="ActorWatcher::assignSlotAwaitRecall(${i})" onClick=${ () => this.assignSlotAwaitRecall(i) } class="pushbutton"><img src="assets/img/Obj_ReverseRecorder.png" /></button>
                        <button title="ActorWatcher::assignSlotAwaitSpawn(${i}, ${getText("string")} ${getText("actorName")}); // ${getText("optional filter by name")}" onClick=${ () => this.assignSlotAwaitSpawn(i) } class="pushbutton">${getText("spawn")}</button>
                        <button title="ActorWatcher::assignSlotAwaitBancEntityHash(${i}, u64 hash); // ${getText("eg")} 0x07b4e71cd2536055" onClick=${ () => this.assignSlotAwaitBancEntityHash(i) } class="pushbutton">Banc</button>
                        <br/>
                        <input placeholder=${getText("selector arg")} size="40" ref=${this.selector_textbox_ref} />
                        <!-- TODO on specific actor's next dep, ... -->
                        <!--<input type="number" placeholder="0" size="2" min="0" max="3" size=2 />-->
                    </div>


                    <div class="actor_pos32">
                        <${ReadoutVec3} title="xyz" label="pos" value=${pos} vecComponentPattern=${VecComponentPatterns.XYZ} />
                    </div>
                    <div class="actor_pos32_ui">
                        <${ReadoutVec3} title="x, -z, y-105.5" label="ui\xa0" value=${VecUtil.engine_to_ui(pos)} vecComponentPattern=${VecComponentPatterns.XZY} />
                    </div>
                    <div class="actor_vel_frame">
                        <${ReadoutVec3} label=${getText("vel")} value=${vel} vecComponentPattern=${VecComponentPatterns.XYZ} /><br />
                    </div>

                    <!--
                    <div class="actor_pos64">
                        <${ReadoutVec3} label=${getText("pos")} value=${dummy} vecComponentPattern=${VecComponentPatterns.XYZ} />
                    </div>
                    <div class="actor_pos64_ui">
                        <${ReadoutVec3} label=${getText("ui\xa0")} value=${VecUtil.engine_to_ui(dummy)} vecComponentPattern=${VecComponentPatterns.XZY} />
                    </div>
                    <div class="actor_compass">
                        <${ReadoutVec2} label=${getText("rot\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0")} value=${dummy} vecComponentPattern=${VecComponentPatterns.ZX} />
                        <${CompassSpinny} value=${dummy} />
                        <br />
                        <${ReadoutQuat} label=${getText("rot_physics")} value=${dummy} />
                        <${CompassSpinnyPhysics} value=${dummy} />
                        <br />
                        <${ReadoutVec3} label=${getText("ang vel\xa0\xa0\xa0\xa0")} value=${dummy} />
                    </div>
                    -->

                    <div class="bumper_pushbuttons">
                        <span>${getText("Move by")} <input style="width: 60px;" type="number" placeholder="10" size="4" min="0" max="10000" step="any" ref=${this.bumper_increment_ref} />m:</span>
                        <br />
                        <br />
                        <button title="y-" style="color: var(--vec-green);" onClick=${ () => this.do_relative_move(i, "DOWN" ) } class="pushbutton">${getText("down")}</button>
                        <button title="z-" style="color: var(--vec-blue);"  onClick=${ () => this.do_relative_move(i, "NORTH") } class="pushbutton">${getText("north")}</button>
                        <button title="y+" style="color: var(--vec-green);" onClick=${ () => this.do_relative_move(i, "UP"   ) } class="pushbutton">${getText("\xa0up\xa0")}</button>
                        <br />
                        <button title="x-" style="color: var(--vec-red);"   onClick=${ () => this.do_relative_move(i, "WEST" ) } class="pushbutton">${getText("west")}</button>
                        <button title="z+" style="color: var(--vec-blue);"  onClick=${ () => this.do_relative_move(i, "SOUTH") } class="pushbutton">${getText("south")}</button>
                        <button title="x+" style="color: var(--vec-red);"   onClick=${ () => this.do_relative_move(i, "EAST" ) } class="pushbutton">${getText("east")}</button>
                    </div>

                    <div class="savestate_slot_actions">
                        ${getText("Coords")}:
                        <button class="pushbutton" onClick=${() => this.dump_pos_to_savestate_textbox() }>${getText("dump")}</button>
                        <button class="pushbutton" onClick=${() => this.do_absolute_move(i)}>${getText("assign")}</button>
                        <br />
                        <input placeholder="x, y, z (${getText("engine")})" ref=${this.savestate_textbox_pos_ref} size=40 />
                        <input placeholder="1,0,0, 0,1,0, 0,0,1" ref=${this.savestate_textbox_rot_ref} size=40 />
                    </div>
                </section>
            `;
        }
    };

    class Actor_MasterList_Search extends Component {
        constructor() {
            super();
            this.state = {
                ui_size: "medium",
                fuzzysort_query: "",
                fuzzysort_results: [],
            };
            this.fuzzy_input_ref = createRef();
        }

        toggle_size() {
            this.setState({ui_size: this.state.ui_size == "medium" ? "small" : "medium"});
        }

        do_search_clear = () => {
            this.setState({fuzzysort_query: "", fuzzysort_results: []});
        }

        do_search_change = (e) => {
            const q = e.currentTarget.value.toString().trim();
            if (!q || q.length < 3) { return this.do_search_clear(); }

            const fuzzysort_results = fuzzysort.go(q, Actor_MasterList_fuzzysort, {
                keys: ["actor", "model", "gameName", "philName"], // exclude "type" column
                threshold: 0.4, // uses "score", different from the negative "_score"! https://github.com/farzher/fuzzysort/issues/135
            });
            //console.log(q, fuzzysort_results);
            this.setState({fuzzysort_query: q, fuzzysort_results: fuzzysort_results});
        }

        do_spawn(actorName) { AngelScript.exec(`actor::createSimple("${actorName}");`); }
        do_objmap(actorName) { window.open(`https://objmap-totk.zeldamods.org/#/map/z2,0,0?q=%5E${actorName}`, "_blank").focus(); }

        render_fuzzysort_results_dialog(props, state) {
            if (!state.fuzzysort_query) { return ""; }

            const items = state.fuzzysort_results.map(fz => {
                // fz.obj is the (prepared) underlying matched object, so fz.obj.actor.target is a const value like "Animal_Kokko_A"
                // fz[n] map to the fuzzysort `keys` option, one for each column:
                //     - fz[2].target will be empty or a match string for gameName
                //     - fz[2].highlight() generates html bolding the matching parts for gameName

                //console.log(fz.obj.actor.target, fz.score, fz);
                const actorName = fz.obj.actor.target;
                // type+actor always present+visible
                const type = html`<label>[${getText(fz.obj.type.target)}]</label>`;
                const actor = fz[0].target ? html`<span class="copy_fake_target" dangerouslySetInnerHTML=${{ __html: fz[0].highlight() }}></span>` : html`<span class="copy_fake_target">${actorName}</span>`;

                // HACK setting innerHTML violates vdom. not worth the effort: add state({copySuccess: actorName}), compare for üìã‚úÖ in here, maybe setTimeout+debounce to reset
                const copy = html`<button class="copy" title=${getText("copy")} onClick=${e => { navigator.clipboard.writeText(actorName); e.target.innerHTML = "‚úÖ"; }}>üìã</button>`;
                const spawn = html`<button title="actor::createSimple(${getText("string")})" onClick=${() => this.do_spawn(actorName) }>${getText("new")}</button>`;
                const objmap = html`<button title=${getText("find in objmap")} onClick=${() => this.do_objmap(actorName) }>${getText("objmap")}</button>`;

                let model = "";
                if (fz[1].target && !fz[0].target) {
                    // model field is verbose, only display if it matches and "actor" didn't
                    model = html`<span dangerouslySetInnerHTML=${{ __html: fz[1].highlight() }}></span>`;
                }
                // wrap or leave empty
                model &&= html`<div class="model"><label>${getText("Model")}: </label>${model}</div>`;

                let gameName = "";
                if (fz[2].target) {
                    // always display match
                    gameName = html`<span dangerouslySetInnerHTML=${{ __html: fz[2].highlight() }}></span>`;
                }
                if (fz.obj.gameName) {
                    // display even if it didn't match
                    gameName ||= fz.obj.gameName.target;
                }
                // wrap or leave empty
                gameName &&= html`<div class="gameName"><label>${getText("GameName")}: </label>${gameName}</div>`;

                let philName = "";
                if (fz[3].target) {
                    // display match
                    philName = html`<span dangerouslySetInnerHTML=${{ __html: fz[3].highlight() }}></span>`;
                }
                if (fz.obj.philName) {
                    // display even if it didn't match
                    philName ||= fz.obj.philName.target;
                }
                // hide gameName duplicates
                philName &&= (fz.obj.gameName && fz.obj.philName.target === fz.obj.gameName.target) ? "" : philName;
                // wrap or leave empty
                philName &&= html`<div class="philName"><label>${getText("PhilName")}: </label>${philName}</div>`;

                return html`<div key=${actorName} class="fuzzysort_results_item">
                    <div class="actor">${type} ${actor} ${copy}${objmap}${spawn}</div>
                    ${model}
                    ${gameName}
                    ${philName}
                    <hr />
                </div>`;
            });

            return html`
                <${SimpleWindow} onClose=${this.do_search_clear}>
                    ${getText("Actors like")} "${state.fuzzysort_query}" (${state.fuzzysort_results.length}):<br />
                    <div class="fuzzysort_results content">${items}</div>
                </${SimpleWindow}>
            `;
        }

        render(props, state) {
            const fuzzyWidth = state.ui_size == "medium" ? 20 : 4;
            return html`
                <div class="Actor_MasterList_Search size_${state.ui_size}">
                    <button title=${getText("Expand/Collapse")} onClick=${ () => this.toggle_size() }>${ state.ui_size == "medium" ? "[-]" : "[+]" }</button>
                    <label class="size_small_hidden" for="Actor_MasterList_Search__fuzzy_input_ref">${getText("ActorDB ")} </label>
                    <input onInput=${this.do_search_change} placeholder="kokko" size=${fuzzyWidth} ref=${this.fuzzy_input_ref} id="Actor_MasterList_Search__fuzzy_input_ref" />
                    ${this.render_fuzzysort_results_dialog(props, state)}
                </div>
            `;
        }
    };

    class Event_NameList_Search extends Component {
        constructor() {
            super();
            this.state = {
                ui_size: "medium",
                fuzzysort_query: "",
                fuzzysort_results: [],
            };
            this.fuzzy_input_ref = createRef();
        }

        toggle_size() {
            this.setState({ui_size: this.state.ui_size == "medium" ? "small" : "medium"});
        }

        do_search_clear = () => {
            this.setState({fuzzysort_query: "", fuzzysort_results: []});
        }

        do_search_change = (e) => {
            const q = e.currentTarget.value.toString().trim();
            if (!q || q.length < 3) { return this.do_search_clear(); }

            const fuzzysort_results = fuzzysort.go(q, Event_NameList_fuzzysort, {
                keys: ["flowchartName"],
                threshold: 0.4, // uses "score", different from the negative "_score"! https://github.com/farzher/fuzzysort/issues/135
            });
            //console.log(q, fuzzysort_results);
            this.setState({fuzzysort_query: q, fuzzysort_results: fuzzysort_results});
        }

        do_request(flowchartName) { AngelScript.exec(`event::requestSimple("${flowchartName}");`); } // TODO starter link

        render_fuzzysort_results_dialog(props, state) {
            if (!state.fuzzysort_query) { return ""; }

            const items = state.fuzzysort_results.map(fz => {
                // fz.obj is the (prepared) underlying matched object, so fz.obj.flowchartName.target is a const value like "DmF_SY_Camp"

                const flowchartName = fz.obj.flowchartName.target;
                const eventflow = fz[0].target ? html`<span class="copy_fake_target" dangerouslySetInnerHTML=${{ __html: fz[0].highlight() }}></span>` : html`<span class="copy_fake_target">${flowchartName}</span>`;

                // HACK setting innerHTML violates vdom
                const copy = html`<button class="copy" title=${getText("copy")} onClick=${e => { navigator.clipboard.writeText(flowchartName); e.target.innerHTML = "‚úÖ"; }}>üìã</button>`;
                const req = html`<button title="event::requestSimple(${getText("string")})" onClick=${() => this.do_request(flowchartName) }>req</button>`;

                return html`<div key=${flowchartName} class="fuzzysort_results_item">
                    <div class="eventflow">${eventflow} ${copy}${req}</div>
                    <hr />
                </div>`;
            });

            return html`
                <${SimpleWindow} onClose=${this.do_search_clear}>
                    ${getText("EventFlows like")} "${state.fuzzysort_query}" (${state.fuzzysort_results.length}):<br />
                    <div class="fuzzysort_results content">${items}</div>
                </${SimpleWindow}>
            `;
        }

        render(props, state) {
            const fuzzyWidth = state.ui_size == "medium" ? 20 : 4;
            return html`
                <div class="Event_NameList_Search size_${state.ui_size}">
                    <button title=${getText("Expand/Collapse")} onClick=${ () => this.toggle_size() }>${ state.ui_size == "medium" ? "[-]" : "[+]" }</button>
                    <label class="size_small_hidden" for="Event_NameList_Search__fuzzy_input_ref">${getText("EventDB ")} </label>
                    <input onInput=${this.do_search_change} placeholder="DmF_SY_Camp" size=${fuzzyWidth} ref=${this.fuzzy_input_ref} id="Event_NameList_Search__fuzzy_input_ref" />
                    ${this.render_fuzzysort_results_dialog(props, state)}
                </div>
            `;
        }
    };

    class GMDHash_InfoList_Search extends Component {
        constructor() {
            super();
            this.fuzzysort_impl = undefined;
            this.state = {
                ui_size: "medium",
                fuzzysort_query: "",
                fuzzysort_results: [],
            };
            this.fuzzy_input_ref = createRef();
        }

        async get_fuzzysort() {
            if (!this.fuzzysort_impl) {
                const mod = await import("/assets/data/GMDHash_InfoList.mjs");
                this.fuzzysort_impl = mod.GMDHash_InfoList_prepare_fuzzysort(fuzzysort);
            }
            return this.fuzzysort_impl;
        }

        toggle_size() {
            this.setState({ui_size: this.state.ui_size == "medium" ? "small" : "medium"});
        }

        do_search_clear = () => {
            this.setState({fuzzysort_query: "", fuzzysort_results: []});
        }

        do_search_change = async (e) => {
            let q = e.currentTarget.value.toString().trim();
            if (!q || q.length < 3) { return this.do_search_clear(); }
            if (parseInt(q, 10) == q) { q = "0x" + parseInt(q, 10).toString(16); } // map ints to hex

            const fzimpl = await this.get_fuzzysort(); // defer preparing search until first use
            const fuzzysort_results = fuzzysort.go(q, fzimpl, {
                keys: ["hex", "key"],
                threshold: 0.4, // uses "score", different from the negative "_score"! https://github.com/farzher/fuzzysort/issues/135
            });
            //console.log(q, fuzzysort_results);
            this.setState({fuzzysort_query: q, fuzzysort_results: fuzzysort_results});
        }

        //do_request(flowchartName) { console.log("uhh"); return; AngelScript.exec(`event::requestSimple("${flowchartName}");`); }

        render_fuzzysort_results_dialog(props, state) {
            if (!state.fuzzysort_query) { return ""; }

            const items = state.fuzzysort_results.map(fz => {
                // fz.obj is the (prepared) underlying matched object, so fz.obj.key.target is a const value like "Pouch"

                const hash = fz.obj.hash.target;
                const hexLabel = fz[0].target ? html`<label class="copy_fake_target" dangerouslySetInnerHTML=${{ __html: fz[0].highlight() }}></label>` : html`<label class="copy_fake_target">${fz.obj.hex.target}</label>`;

                const key = fz.obj.key ? fz.obj.key.target : undefined;
                let keyLabel = key || getText("[unknown]");
                keyLabel = fz[1].target ? html`<span class="copy_fake_target" dangerouslySetInnerHTML=${{ __html: fz[1].highlight() }}></span>` : html`<span class="copy_fake_target">${keyLabel}</span>`;

                // HACK setting innerHTML violates vdom
                const copyHex = html`<button class="copy" title=${getText("copy")} onClick=${e => { navigator.clipboard.writeText(fz.obj.hex.target); e.target.innerHTML = "‚úÖ"; }}>üìã</button>`;
                const copyKey = html`<button class="copy" title=${getText("copy")} onClick=${e => { navigator.clipboard.writeText(key); e.target.innerHTML = "‚úÖ"; }}>üìã</button>`;

                const commentDiv = fz.obj.comment ? html`<div><label>// ${fz.obj.comment.target}</label></div>` : "";
                const typesDiv = fz.obj.types ? html`<div><label>${getText("Types")}: ${fz.obj.types.target}</label></div>` : "";
                const owners = fz.obj.owners ? fz.obj.owners.target : undefined;
                const members = fz.obj.members ? fz.obj.members.target : undefined;
                const ownersDiv = owners ? html`<div><label>${getText("Owners")}: </label>${owners}</div>` : "";
                const membersDiv = members ? html`<div><label>${getText("Members")}: </label>${members}</div>` : "";

                return html`<div key=${fz.obj.hash.target} class="fuzzysort_results_item">
                    <div class="hashinfo">
                        ${hexLabel} ${copyHex} ${keyLabel} ${copyKey}
                        ${commentDiv}
                        ${typesDiv}
                        ${ownersDiv}
                        ${membersDiv}
                    </div>
                    <hr />
                </div>`;
            });

            return html`
                <${SimpleWindow} onClose=${this.do_search_clear}>
                    ${getText("GameData hashes like")} "${state.fuzzysort_query}" (${state.fuzzysort_results.length}):<br />
                    <div class="fuzzysort_results content">${items}</div>
                </${SimpleWindow}>
            `;
        }

        render(props, state) {
            const fuzzyWidth = state.ui_size == "medium" ? 20 : 4;
            return html`
                <div class="GMDHash_InfoList_Search size_${state.ui_size}">
                    <button title=${getText("Expand/Collapse")} onClick=${ () => this.toggle_size() }>${ state.ui_size == "medium" ? "[-]" : "[+]" }</button>
                    <label class="size_small_hidden" for="GMDHash_InfoList_Search__fuzzy_input_ref">${getText("GMDHash")} </label>
                    <input onInput=${this.do_search_change} placeholder="TripMaster" size=${fuzzyWidth} ref=${this.fuzzy_input_ref} id="GMDHash_InfoList_Search__fuzzy_input_ref" />
                    ${this.render_fuzzysort_results_dialog(props, state)}
                </div>
            `;
        }
    };

    class AngelScriptNotebook extends Component {
        constructor() {
            super();
            this.state = {
                index_names: ["builtin", "user"],
                index_builtin: [],
                index_user: [],
                selected_index: "builtin",
                ui_size: "medium",
                dialog_filename: "",
                dialog_contents: "",
            };
            this.notebook_select_ref = createRef();
            this.fetch_notebook_indexes();
        }

        fetch_notebook_indexes() {
            this.state.index_names.forEach(n => {
                fetch(`/angelscript-notebook/index-${n}.json`).then(resp => {
                    const stateKey = `index_${n}`;
                    if (resp.status != 200) {
                        return this.setState({ [stateKey]: [] });
                    }
                    resp.json().then(json => {
                        return this.setState({ [stateKey]: json });
                    });
                });
            });
        }

        do_index_select = (e) => {
            this.setState({selected_index: e.currentTarget.value});
        }

        do_notebook_open() {
            const as_filename = this.notebook_select_ref.current.value;

            // toggle closed if this file already shown
            if (this.state.dialog_contents && this.state.dialog_filename == as_filename) {
                return this.setState({dialog_filename: "", dialog_contents: ""});
            }

            fetch(`/angelscript-notebook/${as_filename}`).then(resp => {
                if (resp.status != 200) { return; }
                resp.text().then(as_text => {
                    //console.log(as_text);
                    this.setState({dialog_filename: as_filename, dialog_contents: as_text})
                });
            });
        }

        toggle_size() {
            this.setState({ui_size: this.state.ui_size == "medium" ? "small" : "medium"});
        }

        do_dialog_clear = () => {
            this.setState({dialog_filename: "", dialog_contents: ""});
        }

        render(props, state) {
            const index_names = state.index_names.map(x => html`<option value="${x}">${getText(x)}</option>`);
            const notebook_names = state[`index_${state.selected_index}`].map(x => html`<option>${x}</option>`);
            const dialog = !(state.dialog_contents) ? "" : html`
                <${SimpleWindow} onClose=${this.do_dialog_clear}>
                    üìñ${state.dialog_filename}<br />
                    <textarea autofocus class="content" contenteditable="plaintext-only">${state.dialog_contents}</textarea>
                </${SimpleWindow}>
            `;

            return html`
                <div class="angelscript_notebook size_${state.ui_size}">
                    <button title=${getText("Expand/Collapse")} onClick=${ () => this.toggle_size() }>${ state.ui_size == "medium" ? "[-]" : "[+]" }</button>
                    <button class="hint_blueprint_strong" title=${getText("Open/Toggle AngelScript notebook")} onClick=${ () => this.do_notebook_open() }>ASüìñ</button>
                    <select class="size_small_hidden" onChange=${this.do_index_select}>
                        ${index_names}
                    </select>
                    <select class="size_small_hidden" ref=${this.notebook_select_ref}>
                        ${notebook_names}
                    </select>
                    ${dialog}
                </div>
            `;
        }
    };

    class RemoteFileBrowser extends Component {
        constructor() {
            super();
            this.state = {
                remote_path: undefined,
                dentries: [],
            };
        }

        componentDidMount() {
            this.load_remote_index("sdcard:/totk_lotuskit");
        }

        load_remote_index(path) {
            this.setState({remote_path: path, dentries: []});
            RemoteFileUtil.reqDirectoryIndex(path).then(newDentries => {
                this.setState({remote_path: path, dentries: newDentries});
            });
        }

        do_traverse_up() {
            let dest = this.state.remote_path.split("/").slice(0, -1).join("/"); // traverse up one
            if (dest === "") { dest = "sdcard:/"; }
            if (dest.slice(-1) == ":") { dest = this.state.remote_path.slice(0, this.state.remote_path.indexOf("/")+1); } // can't traverse above root
            this.load_remote_index(dest);
        }

        do_traverse_down(relpath) {
            let dest = this.state.remote_path.split("/")
            dest.push(relpath);
            this.load_remote_index(dest.filter(x=>x).join("/"));
        }

        render(props, state) {
            let dentryList = state.dentries.map(dentry => {
                if (dentry.type === 0) { // folder
                    return html`<li><a href="#" onClick=${ e => { this.do_traverse_down(dentry.name); e.preventDefault(); return false; } }>${dentry.name}</a></li>`;
                } else if (dentry.type === 1) { // file
                    let usize = dentry.size;
                    let unit = "";
                    if (usize > 0) { unit = "B"; }
                    if (usize > 2*1024) { unit = "KB"; usize /= 1024; }
                    if (usize > 2*1024) { unit = "MB"; usize /= 1024; }
                    if (usize > 2*1024) { unit = "GB"; usize /= 1024; }
                    const fmtSize = html`<span class="filesize">${usize.toFixed(0)} ${unit}</span>`

                    let cpath = state.remote_path;
                    if (cpath.indexOf("sdcard:/totk_lotuskit") == 0) {
                        // canonicalize (make relative to mod home)
                        cpath = cpath.slice("sdcard:/totk_lotuskit".length);
                        if (cpath && cpath[0] == "/") { cpath = cpath.slice(1); }
                    }
                    if (cpath.length > 0 && cpath.slice(-1) != "/") { cpath += "/"; } // root dirs don't need separators
                    cpath += dentry.name;
                    // HACK setting innerHTML violates vdom
                    const copy = html`<button class="copy" title=${getText("copy")} onClick=${e => { navigator.clipboard.writeText(cpath); e.target.innerHTML = "‚úÖ"; }}>üìã</button>`;

                    const pick = props.onPick ? html`<button class="copy" title=${getText("pick")} onClick=${() => { props.onPick(cpath); }}>${getText("pick")}</button>` : "";

                    return html`<li><span class="copy_fake_target">${dentry.name}</span> ${copy} ${pick} ${fmtSize}</li>`;
                }

            });
            if (dentryList.length == 0) { dentryList = [html`<li style="color: #666;">[${getText("empty folder")}]</li>`]; }

            return html`
                <${SimpleWindow} onClose=${props.onClose}>
                    ${getText("Remote files")}
                    <a href="#" onClick=${ e => { this.load_remote_index("sdcard:/"); e.preventDefault(); return false; } } style="margin: 0 12px 0 48px">sdcard:/</a>
                    <a href="#" onClick=${ e => { this.load_remote_index("content:/"); e.preventDefault(); return false; } }>content:/</a>
                    <br /><br />
                    ${state.remote_path}<br />
                    <ul class="filelist" style="min-width: 400px; min-height: 200px; max-height: 60vh; overflow: scroll;">
                        <li><a href="#" onClick=${ e => { this.do_traverse_up(); e.preventDefault(); return false; } }>..</a></li>
                        ${dentryList}
                    </ul>
                </${SimpleWindow}>
            `;
        }
    };

    class ModConnectionUI extends Component {
        constructor() {
            super();
            this.ws_location_ref = createRef();
            let recents = window.sessionStorage.getItem("ws_location_recents") || "ws://127.0.0.1:7072,ws://10.0.0.3:7072";
            recents = recents.split(",");
            this.state = {
                is_polling: false,
                ui_size: "medium",
                ws_location_recents: recents,
                retry_mode: "once",
            };
        }

        do_connect_submit = (e) => {
            const isWsBusy = this.state.is_polling || WSTransport.signals.config.frontend.ws_is_connected.value;
            if (isWsBusy && !e.ctrlKey) { return; } // prevent misclicks from killing active connections

            const ws_location = this.ws_location_ref.current.value || "ws://127.0.0.1:7072";

            let recents = window.sessionStorage.getItem("ws_location_recents") || "ws://127.0.0.1:7072,ws://10.0.0.3:7072";
            recents = recents.split(",");
            if (recents.indexOf(ws_location) == -1) {
                recents.unshift(ws_location); // prepend
                window.sessionStorage.setItem("ws_location_recents", recents);
            }

            if (this.state.retry_mode == "once") {
                return WSTransport.connect(ws_location);
            } else if (this.state.retry_mode == "poll_once") {
                return this.do_poll_once();
            } else if (this.state.retry_mode == "poll_forever") {
                return this.do_poll_forever();
            }
        }

        do_poll_once() {
            // cancel polling on success
            if (WSTransport.signals.config.frontend.ws_is_connected.value) {
                this.setState({is_polling: false});
                return;
            }
            WSTransport.connect(this.ws_location_ref.current.value || "ws://127.0.0.1:7072");
            this.setState({is_polling: true});
            window.setTimeout(this.do_poll_once.bind(this), 5000);
        }

        do_poll_forever() {
            // indicate success, but keep timer going to watch for disconnect
            if (WSTransport.signals.config.frontend.ws_is_connected.value) {
                this.setState({is_polling: false});
            } else {
                WSTransport.connect(this.ws_location_ref.current.value || "ws://127.0.0.1:7072");
                this.setState({is_polling: true});
            }
            window.setTimeout(this.do_poll_forever.bind(this), 5000);
        }

        do_recent_select = (e) => {
            const ws_location = e.currentTarget.value;
            this.ws_location_ref.current.value = ws_location;
        }

        do_retry_mode_select = (e) => {
            const retry_mode = e.currentTarget.value;
            this.setState({retry_mode: retry_mode});
        }

        toggle_size() {
            this.setState({ui_size: this.state.ui_size == "medium" ? "small" : "medium"});
        }

        render(props, state) {
            const recents = state.ws_location_recents.map(x => html`<option>${x}</option>`);
            const flag = WSTransport.signals.config.frontend.ws_is_connected.value ? "‚úÖ" :
                         state.is_polling ? "‚åõ" : "‚ùå";

            const isWsBusy = state.is_polling || WSTransport.signals.config.frontend.ws_is_connected.value;
            const connectStyle = isWsBusy ? "background: #666; color: #aaa;" :  "";
            const connectTitle = isWsBusy ? getText("ctrl+click to force close ws") : getText("connect ws");

            return html`
                <div class="ws size_${state.ui_size}">
                    <button title=${getText("Expand/Collapse")} onClick=${ () => this.toggle_size() }>${ state.ui_size == "medium" ? "[-]" : "[+]" }</button>
                    <span class="size_small_hidden">${getText("Mod Socket")}</span>${flag}
                    <input class="size_small_hidden" placeholder="ws://127.0.0.1:7072" size="20" ref=${this.ws_location_ref} />
                    <button class="hint_recommended_strong" title=${connectTitle} style=${connectStyle} onClick=${this.do_connect_submit}>${getText("go")}</button>
                    <div class="size_small_hidden">
                        <select onChange=${this.do_recent_select}>
                            <option>[${getText("Session Recents")}]</option>
                            ${recents}
                        </select>
                        <select onChange=${this.do_retry_mode_select}>
                            <option disabled>[${getText("Connect/Retry Mode")}]</option>
                            <option value="once">${getText("Try once")}</option>
                            <option value="poll_once" title=${getText("Must 'go' again after disconnect")}>${getText("Poll until success")}</option>
                            <option value="poll_forever" title=${getText("After first 'go', will always retry even after disconnect")}>${getText("Poll forever")}</option>
                        </select>
                    </div>
                </div>
            `;
        }
    };

    // init

    function MainToolbox() {
        return html`
        <div class="toolbox_main">
            <${ActorWatcher} slot_i=0 />
            <${ActorWatcher} slot_i=1 />
            <${ActorWatcher} slot_i=2 />
            <${ActorWatcher} slot_i=3 />
            <section class="toolset_rightbar">
                <${PauseHacks} />
                <${StaminaHacks} />
                <${CameraHacks} />
                <div class="hexdump" style="margin-top: 8px;">
                    HexDump
                    <${HexDumpSlot} slot_i=0 />
                    <${HexDumpSlot} slot_i=1 />
                    <${HexDumpSlot} slot_i=2 />
                    <${HexDumpSlot} slot_i=3 />
                </div>
                <${MemSearch} />
                <${QuickDumps} />
                <${ExecScript} />
            </section>
            <section class="toolset_quickcorner">
                <div class="qc">
                    <${Actor_MasterList_Search} />
                    <${Event_NameList_Search} />
                    <${GMDHash_InfoList_Search} />
                    <${AngelScriptNotebook} />
                    <${ModConnectionUI} />
                </div>
            </section>
        </div>
        `;
    }

    // expose some stuff to devtools
    window.AngelScript = AngelScript;
    window.WSTransport = WSTransport;
    window.RemoteFileUtil = RemoteFileUtil;

    // main entrypoint
    window.addEventListener("load", async function() {
        WSTransport.connect();
        const root = document.querySelector(".root");
        render(html`<${MainToolbox} />`, root);
    });

    window.addEventListener("beforeunload", function() {
        if (WSTransport.websock) { WSTransport.websock.close(); }
    });

    // wild that we have webusb, webbluetooth, webgpu, all this crazy shit and no way to simply read the mouse position
    window.lastMouseClientPagePos = [0, 0];
    document.onmousemove = function(e) {
        window.lastMouseClientPagePos[0] = e.pageX;
        window.lastMouseClientPagePos[1] = e.pageY;
    };

</script>
</head>
<body>
    <div class="root"></div>
</body>
</html>
