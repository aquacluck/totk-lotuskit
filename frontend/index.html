<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" type="text/css" href="assets/style.css" />
    <title>totk-lotuskit</title>
<script type="module">
    import { createRef, h, render, Component } from '/assets/js-vendor/preact@10.23.1.mjs';
    import htm from '/assets/js-vendor/htm@3.1.1.mjs';
    import { signal } from "/assets/js-vendor/preact-signals@1.3.0.mjs";
    const html = htm.bind(h);


    class WSTransport {
        static websock = undefined;
        static ns_subscriptions = {}; // {ns_json_pointer: [cbfunc, ...]}
        static signals = {
            config: {
                frontend: {
                    ws_is_connected: signal(false),
                },
            },
        };

        static send(data, skipEncode) {
            if (!skipEncode) {
                data = JSON.stringify(data);
            }
            WSTransport.websock.send(data);
        }

        static _ws_on_open(e) {
            console.log("ws open success");
            WSTransport.signals.config.frontend.ws_is_connected.value = true;
        }
        static _ws_on_close(e) {
            console.log("ws closed");
            WSTransport.signals.config.frontend.ws_is_connected.value = false;
        }
        static _ws_on_message(e) {
            WSTransport.consume_ws_msg(JSON.parse(e.data));
        }

        static connect(ws_location) {
            if (WSTransport.signals.config.frontend.ws_is_connected.value) {
                console.log("ws closing to reopen");
                WSTransport.signals.config.frontend.ws_is_connected.value = false;
            }
            if (WSTransport.websock) {
                WSTransport.websock.close(); // XXX mod doesnt really know how to close (or reopen TODO), so this will eventually timeout instead
                WSTransport.websock.removeEventListener("open", WSTransport._ws_on_open);
                WSTransport.websock.removeEventListener("close", WSTransport._ws_on_close);
                WSTransport.websock.removeEventListener("message", WSTransport._ws_on_message);
                WSTransport.websock = undefined;
            }

            ws_location = ws_location || "ws://127.0.0.1:7072";
            console.log("ws open try", ws_location);
            WSTransport.websock = new WebSocket(ws_location);
            WSTransport.websock.addEventListener("open", WSTransport._ws_on_open);
            WSTransport.websock.addEventListener("close", WSTransport._ws_on_close);
            WSTransport.websock.addEventListener("message", WSTransport._ws_on_message);
        }

        static consume_ws_msg(payload) {
            const ns = payload.sys.ns;
            if (ns in WSTransport.ns_subscriptions) {
                WSTransport.ns_subscriptions[ns].forEach(cb => cb(payload));

            } else if ("msg" in payload) {
                console.log(payload["msg"]);

            } else if ("err" in payload) {
                console.error(payload["err"]);
            }
        }

        static subscribe_ns(ns, cbfunc) {
            // TODO dedupe, unsubscribe?
            if (ns in WSTransport.ns_subscriptions) {
                WSTransport.ns_subscriptions[ns].push(cbfunc);
            } else {
                WSTransport.ns_subscriptions[ns] = [cbfunc];
            }
        }
    };


    // script format stuff
    function wrap_implicit_main(script_text) {
        return `void main() { ${script_text} \n}`; // newline closes any trailing line comment
    }


    // general vector stuff

    class VecUtil {
        static UI_HEIGHT_OFFSET = 105.5;
        static engine_to_ui(engine_vec3) { return [engine_vec3[0],                       -1 * engine_vec3[2], engine_vec3[1] - VecUtil.UI_HEIGHT_OFFSET]; }
        static ui_to_engine(    ui_vec3) { return [    ui_vec3[0],     ui_vec3[2] + VecUtil.UI_HEIGHT_OFFSET,                           -1 * ui_vec3[1]]; }
    }

    const VecComponentPatterns = {
        XYZ: "XYZ",
        XZY: "XZY",
        ZX:  "ZX",
        ZXY: "ZXY",
    };


    // ui util

    function makeLegibleFloat(value) { return parseFloat(value.toFixed(6)); }

    function CompassSpinny({value}) {
        const [rz, rx] = value;
        const rad = Math.atan2(rz, rx);

        let ns = rz > 0 ? 'S' : 'N';
        let ew = rx > 0 ? 'E' : 'W';
        if (Math.abs(rz) == 1.0) { ew = "\xa0"; }
        if (Math.abs(rx) == 1.0) { ns = "\xa0"; }

        return html`<span style="transform: rotate(${rad}rad);" class="compass_spinny vec_components_${VecComponentPatterns.ZX}"><span>${ns}</span><span>${ew}</span>→</span>`
    }

    function CompassSpinnyPhysics({value}) { // Quaternionf
        const rad = (-2 * Math.atan2(value[1], value[3])) + Math.PI/2;
        // FIXME calc NSEW from rad
        return html`<span style="transform: rotate(${rad}rad);" class="compass_spinny"><span>\xa0</span><span>\xa0</span>→</span>`
    }

    function ReadoutVec3({label, value, vecComponentPattern, title}) {
        const v = value;
        const c = vecComponentPattern || "";
        return html`<span label=${label} title=${title} class="readout readout_vec3 vec_components_${c}"><span>${makeLegibleFloat(v[0])}</span> <span>${makeLegibleFloat(v[1])}</span> <span>${makeLegibleFloat(v[2])}</span></span>`;
    }
    function ReadoutVec2({label, value, vecComponentPattern, title}) {
        const v = value;
        const c = vecComponentPattern || "";
        return html`<span label=${label}  title=${title} class="readout readout_vec2 vec_components_${c}"><span>${makeLegibleFloat(v[0])}</span> <span>${makeLegibleFloat(v[1])}</span></span>`;
    }
    function ReadoutQuat({label, value, vecComponentPattern, title}) {
        const v = value;
        const c = vecComponentPattern || "";
        return html`<span label=${label} title=${title} class="readout readout_quat vec_components_${c}"><span>${makeLegibleFloat(v[0])}</span> <span>${makeLegibleFloat(v[1])}</span> <span>${makeLegibleFloat(v[2])}</span> <span>${makeLegibleFloat(v[3])}</span></span>`;
    }


    // main ui

    class HexDumpSlot extends Component {
        constructor() {
            super();
            this.slotLabelRef = createRef();
            this.slotTargetPtrRef = createRef();
            this.dumpLen = createRef();
            this.drawLen = createRef();
        }

        do_absolute(i) {
            const drawLen = parseInt(this.drawLen.current.value) || 0x20;
            const dumpLen = drawLen;
            const label = this.slotLabelRef.current.value.toString().slice(0, 32).replaceAll(" ", "-") || "_label";
            const ptr = this.slotTargetPtrRef.current.value || 0;
            if (!ptr) { console.log("hexdump user lookin sussy", i); return; }
            WSTransport.send({execScriptString: wrap_implicit_main(`HexDump::assignSlotAbsolute(${i}, ${ptr}, ${dumpLen}, ${drawLen});`)}); // TODO label
            console.log("hexdump absolute", i, ptr, {dumpLen, drawLen, label});
        }
        do_pause(i) {
            WSTransport.send({execScriptString: wrap_implicit_main(`HexDump::pauseSlot(${i});`)});
            console.log("hexdump pause", i);
        }
        do_clear(i) {
            WSTransport.send({execScriptString: wrap_implicit_main(`HexDump::clearSlot(${i});`)});
            console.log("hexdump clear", i);
        }

        render({slot_i}, state) {
            // TODO symbol picker
            return html`
                <div class="hexdump_slot">
                    ${slot_i}${"\xa0"}
                    <input placeholder="any label, max 32" ref=${this.slotLabelRef} />
                    <!-- TODO <select>absolute, main, ...</select> -->
                    <input placeholder="target ptr" size="20" ref=${this.slotTargetPtrRef} />
                    <!--<input placeholder="0x20" size="6" ref=${this.dumpLen} />-->
                    <input placeholder="0x20" size="6" ref=${this.drawLen} />
                    <button onClick=${ () => this.do_absolute(slot_i) } class="pushbutton">dump</button>
                    <button onClick=${ () => this.do_pause(slot_i) } class="pushbutton">pause</button>
                    <button onClick=${ () => this.do_clear(slot_i) } class="pushbutton">clear</button>
                </div>
            `;
        }
    };

    class MemSearch extends Component {
        constructor() {
            super();
            this.needle_ptr_ref = createRef();
        }

        do_search(haystack_name_UNUSED) {
            // TODO more search types
            const needle_ptr = this.needle_ptr_ref.current.value || 0;
            WSTransport.send({execScriptString: wrap_implicit_main(`sys::memSearch(${needle_ptr});`)});
        }

        render(props, state) {
            // TODO region/scope picker
            return html`
                <div class="memsearch">
                    Memory search<span title="crashes on console">⚠️</span><br/>
                    <input placeholder="target ptr" size="20" ref=${this.needle_ptr_ref} />
                    <button title="sys::memSearch(input)" onClick=${ () => this.do_search("sead::HeapMgr::sRootHeaps") } class="pushbutton">heap</button>
                </div>
            `;
        }
    };

    class QuickDumps extends Component {
        // TODO display output somewhere?
        do_heapInfo() { WSTransport.send({execScriptString: wrap_implicit_main("sys::heapInfo();")}); }
        do_threadInfo() { WSTransport.send({execScriptString: wrap_implicit_main("sys::threadInfo();")}); }
        do_hookLimits() { WSTransport.send({execScriptString: wrap_implicit_main("sys::hookLimits();")}); }
        render(props, state) {
            return html`
                <div class="quickdumps">
                    Quick dumps <br/>
                    <button title="sys::heapInfo()" onClick=${ () => this.do_heapInfo() } class="pushbutton">heaps</button>
                    <button title="sys::threadInfo()" onClick=${ () => this.do_threadInfo() } class="pushbutton">threads</button>
                    <button title="sys::hookLimits()" onClick=${ () => this.do_hookLimits() } class="pushbutton">hooks</button>
                </div>
            `;
        }
    };

    class ExecScript extends Component {
        constructor() {
            super();

            this.script_text_ref = createRef();
            this.use_implicit_main_ref = createRef();

            WSTransport.subscribe_ns("/tas/Record", this.recv_tas_record.bind(this))
            this.output_text_ref = createRef();
        }

        do_exec() {
            let script_text = this.script_text_ref.current.value;
            if (this.use_implicit_main_ref.current.checked) {
                script_text = wrap_implicit_main(script_text);
            }
            WSTransport.send({execScriptString: script_text});
        }

        do_toggle_record() {
            WSTransport.send({execScriptString: wrap_implicit_main("tas::toggleDump();")});
        }

        recv_tas_record(payload) {
            const el = this.output_text_ref.current;
            el.value += payload["msg"];
        }

        render(props, state) {
            // TODO local file save/load, copy, ...
            // TODO ctrl+enter do_exec()
            return html`
                <div class="execscript">
                    <br/>AngelScript
                    <button title="Run the script below" onClick=${ () => this.do_exec() } class="pushbutton cta_blue" style="margin-right:16px;">exec</button>
                    <label title="Automatically wrap input into void main() {...} entry point" for="execscript_use_implicit_main">main:</label>
                    <input type="checkbox" id="execscript_use_implicit_main" ref=${this.use_implicit_main_ref} checked />
                    <button title="tas::toggleDump()" onClick=${ () => this.do_toggle_record() } class="pushbutton">tas dump</button>
                    <br/>
                    <textarea class="as_source" placeholder='// check the blue AS📖 button for help \n\n// 1 frame @ 30fps = 2 @ 60fps:\ntas::input(2, KEY_A|KEY_B, 0, -32767, 0, 0);\n\nactor::createAndWatch( \n    1, "SpObj_LiftGeneratorWing_A_01", \n    Player.pos_x, Player.pos_y - 5, Player.pos_z\n);' ref=${this.script_text_ref}></textarea>
                    <textarea placeholder="[tas output]" ref=${this.output_text_ref}></textarea>
                </div>
            `;
        }
    };

    class ActorWatcher extends Component {
        constructor() {
            super();
            this.setState({
                actorName: "[null]",
                actorPtr: 0,
                pos: [0, 0, 0],
                vel: [0, 0, 0],
                rot: [0,0,0, 0,0,0, 0,0,0], // TODO is it even worth rendering this? so noisy
            });
            this.bumper_increment_ref = createRef();
            this.savestate_textbox_pos_ref = createRef();
            this.savestate_textbox_rot_ref = createRef();
        }

        componentDidMount() {
            WSTransport.subscribe_ns(`/ActorWatcher/${this.props.slot_i}`, payload => this.setState(payload));
        }

        assignSlotAwaitRecall(slot_i) {
            WSTransport.send({execScriptString: wrap_implicit_main(`ActorWatcher::assignSlotAwaitRecall(${slot_i});`)});
        }

        clear_slot(slot_i) {
            WSTransport.send({execScriptString: wrap_implicit_main(`ActorWatcher::clearSlot(${slot_i});`)});
        }

        do_paste_coords(slot_i, pos, rot) {
            let r = rot;
            if (pos && r) {
                WSTransport.send({execScriptString: wrap_implicit_main(`ActorWatcher::get(${slot_i}).setPosRot(${pos[0]}, ${pos[1]}, ${pos[2]}, ${r[0]}, ${r[1]}, ${r[2]}, ${r[3]}, ${r[4]}, ${r[5]}, ${r[6]}, ${r[7]}, ${r[8]});`)});
            } else if (pos) {
                WSTransport.send({execScriptString: wrap_implicit_main(`ActorWatcher::get(${slot_i}).setPos(${pos[0]}, ${pos[1]}, ${pos[2]});`)});
            } else if (r) {
                WSTransport.send({execScriptString: wrap_implicit_main(`ActorWatcher::get(${slot_i}).setRot(${r[0]}, ${r[1]}, ${r[2]}, ${r[3]}, ${r[4]}, ${r[5]}, ${r[6]}, ${r[7]}, ${r[8]});`)});
            }
        }

        do_relative_move(slot_i, aaDirection) {
            const delta = parseInt(this.bumper_increment_ref.current.value) || 10.0;
            let pos = [...this.state.pos]; // copy
            switch(aaDirection) {
                case "u": pos[1] += delta; break;
                case "d": pos[1] -= delta; break;
                case "e": pos[0] += delta; break;
                case "w": pos[0] -= delta; break;
                case "s": pos[2] += delta; break;
                case "n": pos[2] -= delta; break;
            }
            this.do_paste_coords(slot_i, pos);
        }

        do_absolute_move(slot_i) {
            let pos = this.savestate_textbox_pos_ref.current.value;
            pos = pos.replaceAll(",", "").split(" ").filter(x => x !== "").map(x => parseFloat(x));
            let rot = this.savestate_textbox_rot_ref.current.value;
            rot = rot.replaceAll(",", "").split(" ").filter(x => x !== "").map(x => parseFloat(x));

            // TODO accept+convert ui coords with a flag
            // XXX generally ignoring physics coords + height offset?
            this.do_paste_coords(slot_i, pos, rot);
        }

        do_send_toggle(slot_i, funcname, rawValue, translateFalseValue, translateTrueValue) {
            const v = ( rawValue && translateTrueValue  !== undefined) ? translateTrueValue  :
                      (!rawValue && translateFalseValue !== undefined) ? translateFalseValue : rawValue;
            WSTransport.send({execScriptString: wrap_implicit_main(`ActorWatcher::${funcname}(${slot_i}, ${v});`)});
        }

        dump_pos_to_savestate_textbox() {
            let v = this.state.pos.map(x => makeLegibleFloat(x));
            this.savestate_textbox_pos_ref.current.value = `${v[0]}, ${v[1]}, ${v[2]}`;
            let r = this.state.rot.map(x => makeLegibleFloat(x));
            this.savestate_textbox_rot_ref.current.value = `${r[0]}, ${r[1]}, ${r[2]}, ${r[3]}, ${r[4]}, ${r[5]}, ${r[6]}, ${r[7]}, ${r[8]}`;
        }

        render(props, state) {
            const {actorName, actorPtr, pos, vel} = state;
            const i = this.props.slot_i;
            const ptr = "0x" + actorPtr.toString(16).padStart(16, "0");
            const dummy = [0, 0, 0, 0]; // XXX

            return html`
                <section class="toolset_actor_watcher">
                    <div class="actor_selector_current">
                        ${actorName}(${ptr})
                        <div class="actor_toggles">
                            <div>
                                <label title="ActorWatcher::doWsLog(${i}, checked)" class="faketoggle doWsLog" for="aw${i}_doWsLog">
                                    <input type="checkbox" id="aw${i}_doWsLog" checked=${state.doWsLog} onChange=${ e => this.do_send_toggle(i, "doWsLog", e.target.checked) } />
                                    <span class="fakebutton pushbutton">ws</span>
                                </label>
                                <label title="ActorWatcher::doTextWriter(${i}, checked)" class="faketoggle doTextWriter" for="aw${i}_doTextWriter">
                                    <input type="checkbox" id="aw${i}_doTextWriter" checked=${state.doTextWriter} onChange=${ e => this.do_send_toggle(i, "doTextWriter", e.target.checked) } />
                                    <span class="fakebutton pushbutton">txt</span>
                                </label>
                                <label title="ActorWatcher::doDrawPos(${i}, checked)" class="faketoggle doDrawPos" for="aw${i}_doDrawPos">
                                    <input type="checkbox" id="aw${i}_doDrawPos" checked=${state.doDrawPos} onChange=${ e => this.do_send_toggle(i, "doDrawPos", e.target.checked) } />
                                    <span class="fakebutton pushbutton">pos</span>
                                </label>
                                <label title="ActorWatcher::doDrawAABB(${i}, checked)" class="faketoggle doDrawAABB" for="aw${i}_doDrawAABB">
                                    <input type="checkbox" id="aw${i}_doDrawAABB" checked=${state.doDrawAABB} onChange=${ e => this.do_send_toggle(i, "doDrawAABB", e.target.checked) } />
                                    <span class="fakebutton pushbutton">AABB</span>
                                </label>
                                <label title="ActorWatcher::doDrawVel(${i}, checked)" class="faketoggle doDrawVel" for="aw${i}_doDrawVel">
                                    <input type="checkbox" id="aw${i}_doDrawVel" checked=${state.doDrawVel} onChange=${ e => this.do_send_toggle(i, "doDrawVel", e.target.checked) } />
                                    <span class="fakebutton pushbutton">vel</span>
                                </label>
                                <label title="ActorWatcher::doDrawAngVel(${i}, checked)" class="faketoggle doDrawAngVel" for="aw${i}_doDrawAngVel">
                                    <input type="checkbox" id="aw${i}_doDrawAngVel" checked=${state.doDrawAngVel} onChange=${ e => this.do_send_toggle(i, "doDrawAngVel", e.target.checked) } />
                                    <span class="fakebutton pushbutton">angv</span>
                                </label>
                                <label title="ActorWatcher::doDrawModelPos(${i}, checked)" class="faketoggle doDrawModelPos" for="aw${i}_doDrawModelPos">
                                    <input type="checkbox" id="aw${i}_doDrawModelPos" checked=${state.doDrawModelPos} onChange=${ e => this.do_send_toggle(i, "doDrawModelPos", e.target.checked) } />
                                    <span class="fakebutton pushbutton">pos</span>
                                </label>
                            </div>

                            <div class="row2">
                                <label title="ActorWatcher::doDrawRigidBodyPos(${i}, flagset_t)" class="faketoggle doDrawRigidBodyPos" for="aw${i}_doDrawRigidBodyPos">
                                    <input type="checkbox" id="aw${i}_doDrawRigidBodyPos" checked=${state.doDrawRigidBodyPos}
                                           onChange=${ e => this.do_send_toggle(i, "doDrawRigidBodyPos", e.target.checked, 0, 0xffffffffffffffffn) } />
                                    <span class="fakebutton pushbutton">pos</span>
                                </label>

                                <label title="ActorWatcher::doDrawRigidBodyPosPast(${i}, flagset_t)" class="faketoggle doDrawRigidBodyPosPast" for="aw${i}_doDrawRigidBodyPosPast">
                                    <input type="checkbox" id="aw${i}_doDrawRigidBodyPosPast" checked=${state.doDrawRigidBodyPosPast}
                                           onChange=${ e => this.do_send_toggle(i, "doDrawRigidBodyPosPast", e.target.checked, 0, 0xffffffffffffffffn) } />
                                    <span class="fakebutton pushbutton">pos-</span>
                                </label>

                                <label title="ActorWatcher::doDrawRigidBodyPosFuture(${i}, flagset_t)" class="faketoggle doDrawRigidBodyPosFuture" for="aw${i}_doDrawRigidBodyPosFuture">
                                    <input type="checkbox" id="aw${i}_doDrawRigidBodyPosFuture" checked=${state.doDrawRigidBodyPosFuture}
                                           onChange=${ e => this.do_send_toggle(i, "doDrawRigidBodyPosFuture", e.target.checked, 0, 0xffffffffffffffffn) } />
                                    <span class="fakebutton pushbutton">pos+</span>
                                </label>

                                <label title="ActorWatcher::doDrawRigidBodyAABB(${i}, flagset_t)" class="faketoggle doDrawRigidBodyAABB" for="aw${i}_doDrawRigidBodyAABB">
                                    <input type="checkbox" id="aw${i}_doDrawRigidBodyAABB" checked=${state.doDrawRigidBodyAABB}
                                           onChange=${ e => this.do_send_toggle(i, "doDrawRigidBodyAABB", e.target.checked, 0, 0xffffffffffffffffn) } />
                                    <span class="fakebutton pushbutton">AABB</span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <div class="actor_selector_options">
                        Select:
                        <button title="ActorWatcher::clearSlot(${i})" onClick=${ () => this.clear_slot(i) } class="pushbutton selectNull">null</button>
                        <button title="ActorWatcher::assignSlotAwaitRecall(${i})" onClick=${ () => this.assignSlotAwaitRecall(i) } class="pushbutton selectRecall"><img src="assets/img/Obj_ReverseRecorder.png" /></button>
                        <!-- TODO on any next spawn, on specific actor's next dep, ... -->
                        <!--<input type="number" placeholder="0" size="2" min="0" max="3" size=2 />-->
                    </div>


                    <div class="actor_pos32">
                        <${ReadoutVec3} title="xyz" label="pos" value=${pos} vecComponentPattern=${VecComponentPatterns.XYZ} />
                    </div>
                    <div class="actor_pos32_ui">
                        <${ReadoutVec3} title="x, -z, y-105.5" label="ui\xa0" value=${VecUtil.engine_to_ui(pos)} vecComponentPattern=${VecComponentPatterns.XZY} />
                    </div>
                    <div class="actor_vel_frame">
                        <${ReadoutVec3} label="vel" value=${vel} vecComponentPattern=${VecComponentPatterns.XYZ} /><br />
                    </div>

                    <!--
                    <div class="actor_pos64">
                        <${ReadoutVec3} label="pos" value=${dummy} vecComponentPattern=${VecComponentPatterns.XYZ} />
                    </div>
                    <div class="actor_pos64_ui">
                        <${ReadoutVec3} label="ui\xa0" value=${VecUtil.engine_to_ui(dummy)} vecComponentPattern=${VecComponentPatterns.XZY} />
                    </div>
                    <div class="actor_compass">
                        <${ReadoutVec2} label="rot\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0" value=${dummy} vecComponentPattern=${VecComponentPatterns.ZX} />
                        <${CompassSpinny} value=${dummy} />
                        <br />
                        <${ReadoutQuat} label="rot_physics" value=${dummy} />
                        <${CompassSpinnyPhysics} value=${dummy} />
                        <br />
                        <${ReadoutVec3} label="ang vel\xa0\xa0\xa0\xa0" value=${dummy} />
                    </div>
                    -->

                    <div class="bumper_pushbuttons">
                        <span>Move by <input type="number" placeholder="10" size="4" min="0" max="10000" step="any" ref=${this.bumper_increment_ref} />m:</span>
                        <br />
                        <br />
                        <button title="y-" style="color: var(--vec-green);" onClick=${ () => this.do_relative_move(i, "d") } class="pushbutton">down</button>
                        <button title="z-" style="color: var(--vec-blue);"  onClick=${ () => this.do_relative_move(i, "n") } class="pushbutton">north</button>
                        <button title="y+" style="color: var(--vec-green);" onClick=${ () => this.do_relative_move(i, "u") } class="pushbutton">\xa0up\xa0</button>
                        <br />
                        <button title="x-" style="color: var(--vec-red);"   onClick=${ () => this.do_relative_move(i, "w") } class="pushbutton">west</button>
                        <button title="z+" style="color: var(--vec-blue);"  onClick=${ () => this.do_relative_move(i, "s") } class="pushbutton">south</button>
                        <button title="x+" style="color: var(--vec-red);"   onClick=${ () => this.do_relative_move(i, "e") } class="pushbutton">east</button>
                    </div>

                    <div class="savestate_slot_actions">
                        Coords:
                        <button class="pushbutton" onClick=${() => this.dump_pos_to_savestate_textbox() }>dump</button>
                        <button class="pushbutton" onClick=${() => this.do_absolute_move(i)}>assign</button>
                        <br />
                        <input placeholder="x, y, z (engine)" ref=${this.savestate_textbox_pos_ref} size=40 />
                        <input placeholder="1,0,0, 0,1,0, 0,0,1" ref=${this.savestate_textbox_rot_ref} size=40 />
                    </div>
                </section>
            `;
        }
    };

    class AngelScriptNotebook extends Component {
        constructor() {
            super();
            this.state = {
                index_names: ["builtin", "user"],
                index_builtin: [],
                index_user: [],
                selected_index: "builtin",
                ui_size: "medium",
                dialog_filename: "",
                dialog_contents: "",
            };
            this.notebook_select_ref = createRef();
            this.fetch_notebook_indexes();
        }

        fetch_notebook_indexes() {
            this.state.index_names.forEach(n => {
                fetch(`/angelscript-notebook/index-${n}.json`).then(resp => {
                    const stateKey = `index_${n}`;
                    if (resp.status != 200) {
                        return this.setState({ [stateKey]: [] });
                    }
                    resp.json().then(json => {
                        return this.setState({ [stateKey]: json });
                    });
                });
            });
        }

        do_index_select = (e) => {
            this.setState({selected_index: e.currentTarget.value});
        }

        do_dialog_keydown = (e) => {
            if (e.key == "Escape" || e.keyCode == 27) {
                // close
                e.preventDefault();
                this.setState({dialog_filename: "", dialog_contents: ""});
            }
        }

        do_notebook_open() {
            const as_filename = this.notebook_select_ref.current.value;

            // toggle closed if this file already shown
            if (this.state.dialog_contents && this.state.dialog_filename == as_filename) {
                return this.setState({dialog_filename: "", dialog_contents: ""});
            }

            fetch(`/angelscript-notebook/${as_filename}`).then(resp => {
                if (resp.status != 200) { return; }
                resp.text().then(as_text => {
                    //console.log(as_text);
                    this.setState({dialog_filename: as_filename, dialog_contents: as_text})
                });
            });
        }

        toggle_size() {
            this.setState({ui_size: this.state.ui_size == "medium" ? "small" : "medium"});
        }

        render(props, state) {
            const index_names = state.index_names.map(x => html`<option>${x}</option>`);
            const notebook_names = state[`index_${state.selected_index}`].map(x => html`<option>${x}</option>`);

            const dialog = !(state.dialog_contents) ? "" : html`
                <dialog onKeyDown=${this.do_dialog_keydown} open>
                    📖${state.dialog_filename}<br />
                    <textarea autofocus contenteditable="plaintext-only">${state.dialog_contents}</textarea>
                </dialog>`;

            return html`
                <div class="angelscript_notebook size_${state.ui_size}">
                    <button title="Expand/Collapse" onClick=${ () => this.toggle_size() }>${ state.ui_size == "medium" ? "[-]" : "[+]" }</button>
                    <button class="cta_blue" title="Open/Toggle AngelScript notebook" onClick=${ () => this.do_notebook_open() }>AS📖</button>
                    <select class="size_small_hidden" onChange=${this.do_index_select}>
                        ${index_names}
                    </select>
                    <select class="size_small_hidden" ref=${this.notebook_select_ref}>
                        ${notebook_names}
                    </select>
                    ${dialog}
                </div>
            `;
        }
    };

    class ModConnectionUI extends Component {
        constructor() {
            super();
            this.ws_location_ref = createRef();
            let recents = window.sessionStorage.getItem("ws_location_recents") || "ws://127.0.0.1:7072,ws://10.0.0.3:7072";
            recents = recents.split(",");
            this.state = {
                is_polling: false,
                ui_size: "medium",
                ws_location_recents: recents,
                retry_mode: "once",
            };
        }

        do_connect_submit() {
            const ws_location = this.ws_location_ref.current.value || "ws://127.0.0.1:7072";

            let recents = window.sessionStorage.getItem("ws_location_recents") || "ws://127.0.0.1:7072,ws://10.0.0.3:7072";
            recents = recents.split(",");
            if (recents.indexOf(ws_location) == -1) {
                recents.unshift(ws_location); // prepend
                window.sessionStorage.setItem("ws_location_recents", recents);
            }

            if (this.state.retry_mode == "once") {
                return WSTransport.connect(ws_location);
            } else if (this.state.retry_mode == "poll_once") {
                return this.do_poll_once();
            } else if (this.state.retry_mode == "poll_forever") {
                return this.do_poll_forever();
            }
        }

        do_poll_once() {
            // cancel polling on success
            if (WSTransport.signals.config.frontend.ws_is_connected.value) {
                this.setState({is_polling: false});
                return;
            }
            WSTransport.connect(this.ws_location_ref.current.value || "ws://127.0.0.1:7072");
            this.setState({is_polling: true});
            window.setTimeout(this.do_poll_once.bind(this), 5000);
        }

        do_poll_forever() {
            // indicate success, but keep timer going to watch for disconnect
            if (WSTransport.signals.config.frontend.ws_is_connected.value) {
                this.setState({is_polling: false});
            } else {
                WSTransport.connect(this.ws_location_ref.current.value || "ws://127.0.0.1:7072");
                this.setState({is_polling: true});
            }
            window.setTimeout(this.do_poll_forever.bind(this), 5000);
        }

        do_recent_select = (e) => {
            const ws_location = e.currentTarget.value;
            this.ws_location_ref.current.value = ws_location;
        }

        do_retry_mode_select = (e) => {
            const retry_mode = e.currentTarget.value;
            this.setState({retry_mode: retry_mode});
        }

        toggle_size() {
            this.setState({ui_size: this.state.ui_size == "medium" ? "small" : "medium"});
        }

        render(props, state) {
            const recents = state.ws_location_recents.map(x => html`<option>${x}</option>`);
            const flag = WSTransport.signals.config.frontend.ws_is_connected.value ? "✅" :
                         state.is_polling ? "⌛" : "❌";

            // easy to misclick and kill the connection in this arrangement, just don't allow it.
            // this also makes collapsing the panel feel like "locking" the connection
            let inertStyle = "";
            if (state.ui_size == "small" && (WSTransport.signals.config.frontend.ws_is_connected.value || state.is_polling)) {
                inertStyle = "pointer-events: none; background: #666; color: #aaa;";
            }

            return html`
                <div class="ws size_${state.ui_size}">
                    <button title="Expand/Collapse" onClick=${ () => this.toggle_size() }>${ state.ui_size == "medium" ? "[-]" : "[+]" }</button>
                    <span class="size_small_hidden">Mod Socket</span>${flag}
                    <input class="size_small_hidden" placeholder="ws://127.0.0.1:7072" size="20" ref=${this.ws_location_ref} />
                    <button class="cta_green" title="connect ws" style=${inertStyle} onClick=${ () => this.do_connect_submit() }>go</button>
                    <div class="size_small_hidden">
                        <select onChange=${this.do_recent_select}>
                            <option>[Session Recents]</option>
                            ${recents}
                        </select>
                        <select onChange=${this.do_retry_mode_select}>
                            <option disabled>[Connect/Retry Mode]</option>
                            <option value="once">Try once</option>
                            <option value="poll_once" title="Must 'go' again after disconnect">Poll until success</option>
                            <option value="poll_forever" title="After first 'go', will always retry even after disconnect">Poll forever</option>
                        </select>
                    </div>
                </div>
            `;
        }
    };

    // init

    function MainToolbox() {
        return html`
        <div class="toolbox_main">
            <${ActorWatcher} slot_i=0 />
            <${ActorWatcher} slot_i=1 />
            <${ActorWatcher} slot_i=2 />
            <${ActorWatcher} slot_i=3 />
            <section class="toolset_memutils_controller">
                <div class="hexdump">
                    HexDump
                    <${HexDumpSlot} slot_i=0 />
                    <${HexDumpSlot} slot_i=1 />
                    <${HexDumpSlot} slot_i=2 />
                    <${HexDumpSlot} slot_i=3 />
                </div>
                <${MemSearch} />
                <${QuickDumps} />
                <${ExecScript} />
            </section>
            <section class="toolset_quickcorner">
                <div class="qc">
                    <${AngelScriptNotebook} />
                    <${ModConnectionUI} />
                </div>
            </section>
        </div>
        `;
    }

    window.addEventListener("load", async function() {
        WSTransport.connect();
        const toolbox = document.querySelector(".toolbox_main");
        render(html`<${MainToolbox} />`, toolbox);
    });

    window.addEventListener("beforeunload", function() {
        if (WSTransport.websock) { WSTransport.websock.close(); }
    });

</script>
</head>
<body>
    <div class="toolbox_main"></div>
</body>
</html>
